* Section 28
** Algorithms that Backtrack
   Solving problems does not always proceed on a direct route to the
   goal. Sometimes we make progress by pursuing one approach only to
   discover that we are stuck because we took a wrong turn. In those
   cases, we backtrack in our exploration and take a different turn at
   some branch, in the hope that it leads us to a solution. Algorithms
   can proceed like that. In the first subsection, we deal with an
   algorithm that can help us traverse a graph, which is of course the
   situation we just discussed. The second subsection is an extended
   exercise that uses backtracking in the context of chess.

*** 28.1 Traversing Graphs
    On occasion, we need to navigate through a maze of one-way
    streets. Or, we may wish to draw a graph of whom we consider a
    friend, whom they consider a friend, and so on. Or, we ask the
    Internet to find some way to send a message from one place to
    another.

    All these situations share a common element: a _directed
    graph_. Specifically, there is always some collection of *nodes*
    and a collection of *edges*. The edges represent one-way
    connections between the nodes. Consider figure 76. The black
    bullets are the nodes; the arrows between them are the one-way
    connections. The sample graph consists of seven nodes and nine
    edges.

    Now suppose we wish to plan routes in the graph of figure 76. For
    example, if we plan to go from C to D, the route is simple: it
    consists of the origination node C and the destination node D. In
    contrast, if we wish to travel from E to D, we have two choices:

    1. We either travel from E to F and then to D.
    2. Or, we travel from E to C and then to D. 

    For some nodes, however, it is impossible to connect them. In
    particular, it is impossible in our sample graph to move from C to
    G by following the arrows.

    In the real world, graphs have more than just seven nodes and many
    more edges. Hence it is natural to develop functions that plan
    routes in graphs. Following the general design recipe, we start
    with a data analysis. Here is a compact representation of the
    graph in figure 76 using lists:

    #+BEGIN_SRC scheme
    (define Graph
     '((A (B E))
       (B (E F))
       (C (D))
       (D ())
       (E (C F))
       (F (D G))
       (G ())))
    #+END_SRC

    The list contains one list per node. Each of these lists starts
    with the name of a node followed by a list of its *neighbors*. For
    example, the second list represents node B and its two outgoing
    edges to E and F.

    - Exercise 28.1.1. Translate the above definition into proper list
      form using list and proper symbols.

      #+BEGIN_SRC scheme
      (define Graph
       (list 
        (list 'A (list 'B 'E))
        (list 'B (list 'E 'F))
        (list 'C (list 'D))
        (list 'D empty)
        (list 'E (list 'C 'F))
        (list 'F (list 'D 'G))
        (list 'G empty)))
      #+END_SRC

      The data definition for a node is straightforward: A *node* is a
      symbol.

      Formulate a data definition for graphs with arbitrarily many
      nodes and edges. The data definition must specify a class of
      data that contains Graph.
      
      #+BEGIN_EXAMPLE
      a Graph is:
      1. empty
      2. (cons node-and-neighbors Graph)
 
      a node-and-neighbors is:
      (cons node (cons list-of-nodes empty))

      a node is a symbol
      a list-of-nodes is:
      1. empty
      2. (cons node list-of-nodes)

      a slick way of saying all this is:
      (listof (list node (listof node)))
      #+END_SRC

    Based on the data definitions for node and graph, we can now
    produce the first draft of a contract for find-route, the function
    that searches a route in a graph:

    #+BEGIN_SRC scheme
    ;; find-route : node node graph -> (listof node)
    ;; to create a path from origination to destination in G
    (define (find-route origination destination G) ...)
    #+END_SRC
    
    What this header leaves open is the exact shape of the result. It
    implies that the result is a list of nodes, but it does not say
    exactly which nodes the list contains. To understand this aspect,
    we must study some examples.

    Consider the first problem mentioned above. Here is an expression
    that formulates the problem in Scheme:

    #+BEGIN_SRC scheme
    (find-route 'C 'D Graph)
    #+END_SRC

    A route from 'C to 'D consists of just two nodes: the origination
    and the destination node. Hence, we should exprect the answer
    (list 'C 'D). Of course, one might argue that since both the
    origination node and the destination node are known, the result
    should be empty. Here we choose the first alternative since it is
    more natural, but it requires only a minor change of the final
    function to produce the latter.

    Now consider our second problem, going from 'E to 'D, which is
    more representative of the kinds of problems we might
    encounter. One natural idea is to inspect all of the neighbors of
    'E and find a route from one of them to 'D. In our sample graph,
    'E has two neighbors: 'C and 'F. Suppose for a moment that we
    didn't know the route yet. In that case, we could again inspect
    all of the neighbors of 'C and find a route from those to our
    goal. Of course, 'C has a single neighbor and it is 'D. Putting
    together the results of all stages shows that the final result is
    (list 'E 'C 'D).
    
    Our final example poses a new problem. Suppose find-route is given
    the arguments 'C, 'G and Graph. In this case, we know from
    inspecting figure 76 that there is no connecting route. To signal
    the lack of a route, find-route should produce a value that cannot
    be mistaken for a route. One good choice is false, a value that
    isn't a list and naturally denotes the failure of a function to
    compute a proper result.

    This new agreement requires another change in our contract:

    #+BEGIN_SRC scheme
    ;; find-route : node node graph -> (listof node) or false
    ;; to create a path from origination to destination in G
    ;; if there is no path, the function produces false.
    (define (find-route origination destination G) ...)
    #+END_SRC

    Our next step is to understand the four essential pieces of the
    function: the ``trivial problem'' condition, a matching solution,
    the generation of a new problem, and the combination step. The
    discussion of the three examples suggests answers. First, if the
    origination argument of find-route is equal to its destination,
    the problem is trivial; the matching answer is (list
    destination). Second, if the arguments are different, we must
    inspect all neighbors of origination in graph and determine
    whether there is a route from one of those to destination.

    Since a node can have an arbitrary number of neighbors, this task
    is too complex for a single primitive. We need an auxiliary
    function. The task of the auxiliary function is to consume a list
    of nodes and to determine for each of them whether there is a
    route to the destination node in the given graph. Put differently,
    this function is a list-oriented version of find-route. Let us
    call this function find-route/list. Here is a translation of this
    informal description into a contract, header, and purpose
    statement:

    #+BEGIN_SRC scheme
    ;; find-route/list : (listof node) node graph -> (listof node) or false
    ;; to create a path from some node on lo-originations to
    ;; destination if there is no path, the function returns false.
    (define (find-route/list lo-originations destination G) ...)
    #+END_SRC

    Now we can write a first draft of find-route as follows:

    #+BEGIN_SRC scheme
    (define (find-route origination destination G)
      (cond
        [(symbol=? origination destination) (list destination)]
        [else
           ... (find-route/list (neighbors origination G) destination G) ...]))
    #+END_SRC

    The function neighbors generates a whole list of problems: the
    problems of finding routes from the neighbors of origination to
    destination. Its definition is a straightforward exercise in
    structural processing.
    
    - Exercise 28.1.2. Develop the function neighbors. It consumes a
      node n and a graph g and produces the list of neighbors of n in
      g. 

      #+BEGIN_SRC scheme
      ;; examples: 
      (equal? (neighbors 'A Graph) (list 'B 'E))
      (equal? (neighbors 'B Graph) (list 'E 'F))
      (equal? (neighbors 'G Graph) empty)
      ;; template:
      (define (neighbors node G) 
        (cond
          ((empty? G) (error 'neighbors "node not found" node))
          (else
           (cond
             ((symbol=? (first (first G)) node)
              (first (rest (first G))))
             (else (neighbors node (rest G)))))))
      #+END_SRC

    Next we need to consider what find-route/list produces. If it
    finds a route from any of the neighbors, it produces a route
    from that neighbor to the final destination. But, if none of the
    neighbors is connected to the destination, the function produces
    fallse. Clearly, find-route's answer depends on what
    find-route/list produces. Hence we should distinguish the answers
    with a cond-expression:

    #+BEGIN_SRC scheme
    (define (find-route origination destination G)
      (cond
        [(symbol=? origination destination) (list destination)]
        [else (local ((define possible-route
                              (find-route/list (neighbors origination G)
                                               destination G)))
                (cond 
                  [(boolean? route) ...]
                  [else ...]))]))
    #+END_SRC

    The two cases reflect the two kinds of answers we might receive: a
    boolean or a list. If find-route/list produces false, it failed to
    find a route from origination's neighbors and it is therefore
    impossible to reach destination at all. The answer in this case
    must therefore be false. In contrast, if find-route/list produces
    a list, the answer must be a route from origination to
    destination. Since possible-route starts with one of origination's
    neighbors, it suffices to add origination to the front of
    possible-route.

    #+BEGIN_SRC scheme
    (define (find-route origination destination G)
      (cond
        [(symbol=? origination destination) (list destination)]
        [else (local ((define possible-route
                              (find-route/list (neighbors origination G)
                                               destination 
                                               G)))
                (cond
                  [(boolean? possible-route)
                   false]
                  [else (cons origination possible-route)]))]))
    (define (find-route/list neighbors destination G) 
      (cond
        [(empty? neighbors) false]
        [else (local ((define possible-route (find-route (first neighbors) 
                                                         destination
                                                         G)))
                (cond
                  [(boolean? possible-route)
                   (find-route/list (rest neighbors) destination G)]
                  [else possible-route]))]))
    #+END_SRC

    Figure 77 contains the complete definition of find-route. It also
    contains a definition of find-route/list, which processes its
    first argument via structural recursion. For each node in the
    list, find-route/list uses find-route to check for a route. If
    find-route indeed produces a route, that route is the
    answer. Otherwise, if find-route fails and produces false, the
    function recurs. In other words, it backtracks its current choice
    of a starting position, (first lo-0s), and instead tries the next
    one in the list. For that reason, find-route is often called a
    BACKTRACKING ALGORITHM.

    *Backtracking in the Structural World*: Intermezzo 3 discusses
    backtracking in the structural world. A particularly good example
    is exercise 18.1.13, which concerns a backtracking function for
    family trees. The function first searches one branch of a family
    tree for a blue-eyed ancestor and, if this search produces false,
    it searches the other half of the tree. Since graphs generalize
    trees, comparing the two functions is an instructive exercise. 

    Last, but not least, we need to understand whether the function
    produces an answer in all situations. The second one,
    find-route/list, is structurally recursive and therefore always
    produces some value, assuming find-route always does. For
    find-route the answer is far from obvious. For example, when given
    the graph in figure 76 and two nodes in the graph, find-route
    always produces some answer. For other graphs, however, it does
    not always terminate. 

    - Exercise 28.1.3. Test find-route. Use it to find a route from A
      to G in the graph of figure 76. Ensure that it produces false
      when asked to find a route from C to G.
    - Exercise 28.1.4. Develop the function test-on-all-nodes, which
      consumes a graph g and tests find-route on all pairs of nodes in
      g. Test the function on Graph.

      #+BEGIN_SRC scheme
      (define (test-on-all-nodes g)
        (map 
         (lambda (node-1)
           (map (lambda (node-2)
                  (find-route (first node-1) (first node-2) g))
             g)) g))
      #+END_SRC

    Consider the graph in figure 78. It differs radically from the
    graph in figure 76 in that it is possible to start a route in a
    node and to return to the same node. Specifically, it is possible
    to move from B to E to C and back to B. And indeed, if applied
    find-route to 'B 'D and a representation of the graph, it fails to
    stop. Here is the hand-evaluation:

    #+BEGIN_SRC scheme
       (find-route 'B 'D Cyclic-graph)
    = ... (find-route 'B 'D Cyclic-Graph) ...
    = ... (find-route/list (list 'E 'F) 'D Cyclic-graph) ...
    = ... (find-route 'E 'D Cyclic-graph) ...
    = ... (find-route/list (list 'C 'F) 'D Cyclic-graph)
    = ... (find-route 'C 'D Cyclic-graph) ...
    = ... (find-route/list (list 'B 'D) 'D Cyclic-graph)
    = ... (find-route 'B 'D Cyclic-graph)
    #+END_SRC

    where Cyclic-Graph stands for a Scheme representation of the graph
    in figure 78. The hand-evaluation shows that after seven
    applications of find-route and find-route/list the computer must
    evaluate the exact same expression from which we started. Since
    the same input produces the same output and the same behavior for
    functions, we know that the function loops forever and does not
    produce a value.

    In summary, if some given graph is cycle-free, find-route produces
    some output for any give inputs. After all, every route can only
    contain a finite number of nodes, and the number of routes is
    finite too. The function therefore either exhaustively inspects
    all solutions starting from some given node, or finds a route from
    the origination to the destination node. If, however, a graph
    contains a cycle, that is, a route from some node back to itself,
    find-route may not produce a result for some inputs. In the next
    part, we study a programming technique that helps us find routes
    even in the presence of cycles in a graph.

    - Exercise 28.1.5. Test find-route on 'B, 'C and the graph in
      figure 78. Use the ideas of section 17.8 to formulate the tests
      as boolean valued expressions.

      #+BEGIN_SRC scheme
      (define Cyclic-graph
        '((A (B E))
          (B (F E))
          (C (D B))
          (D ())
          (E (C F))
          (F (D G))
          (G ())))
      (equal? (find-route 'B 'C Cyclic-graph)
              (list 'B 'E 'C))
      (equal? (find-route 'C 'B Cyclic-graph)
              (list 'C 'B))
      (equal? (find-route 'C 'E Cyclic-graph)
              (list 'C 'B 'E))
      #+END_SRC
    - Exercise 28.1.6. Origanize the find-route program as a single
      function definition. Remove parameters from the locally defined
      functions.

      #+BEGIN_SRC scheme
      (define (find-route origination destination G)
        (cond
          ((symbol=? origination destination) (list origination))
          (else
           (local ((define (neighbors who G)
                     (cond
                       ((empty? G) (error 'find-route 
                                           "Nonexistent node requested:"
                                           who))
                       (else (cond ((symbol=? who (first (first G))) 
                                    (first (rest (first G))))
                                   (else (neighbors who (rest G)))))))
                   (define (find-route/list neighbors destination G)
                     (cond
                       ((empty? neighbors) false)
                       (else (local ((define possible-route
                                             (find-route (first neighbors)
                                                         destination G)))
                               (cond ((boolean? possible-route)
                                      (find-route/list (rest neighbors)
                                                       destination G))
                                     (else possible-route))))))
                    (define possible-route (find-route/list 
                                            (neighbors origination G)
                                            destination G)))
              (cond ((boolean? possible-route) false)
                    (else (cons origination 
                                (find-route/list (neighbors origination G) 
                                                  destination G))))))))

      (define Graph
        '((A (B E))
          (B (E F))
          (C (D))
          (D ())
          (E (C F))
          (F (D G))
          (G ())))
      (equal? (find-route 'A 'B Graph) (list 'A 'B))
      (equal? (find-route 'A 'C Graph) (list 'A 'E 'C))
      (equal? (find-route 'A 'G Graph) '(A B F G))
      (equal? (find-route 'A 'D Graph) '(A B F D))
      (equal? (find-route 'G 'D Graph) false)
      (equal? (find-route 'D 'A Graph) false)
      #+END_SRC


*** Section 28.2 Extended exercise: Checking (on) Queens
    A famous problem in the game of chess concerns the placement of
    queens on a board. For our purposes, a chessboard is a ``square''
    of, say, eight-by-eight or three-by-three tiles. The queen is a
    game piece that can move in a horizontal, vertical, or diagonal
    directoin arbitrarily far. We say that a queen *threatens* a tile
    if it is on the tile or can move to it. Figure 79 shows an
    example. The solid disk represents a queen in the second column
    and sixth row. The solid lines radiating from the disk go through
    all those tiles that are threatened by the queen.

    The queen-placement problem is to place eight queens on a
    chessboard of eight-by-eight tiles such that the queens on the
    board don't threaten each other. In computing, we generalize the
    problem of course and ask whether we can place n queens on some
    board of arbitrary size m by m.

    Even a cursory glance at the problem suggests that we need a data
    representation of boards and some bsaic functions on boards before
    we can even think of designing a program that solves the
    problem. Let's start with some basic data and function
    definitions.
    
    - Exercise 28.2.1. Develop a data definition for chessboards.

      #+BEGIN_SRC scheme
      (listof (listof piece))
      a piece is a symbol:
      1. 'queen if it is threatened or;
      2. 'empty

      that is, a board is:
      1. empty
      2. (cons row board)

      where a row is:
      1. empty
      2. (cons piece row)

      in a valid board the number of rows is the same as the number of
      columns, that is, the number of rows in the board is the same as the
      number of pieces in each row, and each row has the same number of pieces.
      #+END_SRC


    Next we need a function for creating a board and another one for
    checking on a specific tile. Following the examples of lists,
    let's define build-board and board-ref.

    - Exercise 28.2.2 Develop the following tow functions on
      chessboards:
      
      #+BEGIN_SRC scheme
      ;; build-board : N (N N -> boolean) -> board
      ;; to create a board of size n x n
      ;; fill each position with indices i and j with (f i j).
      (define (build-board n f) ...)

      ;; board-ref : board N N -> boolean
      ;; to access a position with indices i, j on a-board
      (define (board-ref a-board i j) ...)
      #+END_SRC

      Test them rigorously!
      
      We immediately see that we will need a function for individual
      rows for each since they are their own complex type.

      #+BEGIN_SRC scheme
      ;; build-board-row : N (N -> boolean) -> board
      ;; to create a board row of size n.
      ;; fill each position with column j with (f j).
      (define (build-board-row n f) ...)

      ;; board-row-ref : N -> piece
      ;; access a position in the row at column j.
      (define (board-row-ref j) ...)
      #+END_SRC

      For column and row numbering, how the actual data is layed out
      doesn't matter so long  as the function gets the right numbers
      and we return the same 'cell' that the function generated in
      subsequent calls to board-ref. 

      When building a board in a general, structurally-recursive way
      for creating a list we end up with something like:

      #+BEGIN_EXAMPLE
           N ...  ... 1
      N ( (             )
       .  (             )
       .  (             )
      1   (             ) )
      #+END_EXAMPLE
      
      But if create a naive, simple implementation of board-ref, we'd
      have a problem if we ask for 1x1, we would get 3x3 or 4x4,
      because we'd subtract recursively. The solution isn't trivial;
      since although we could solve it by using the complement of those numbers
      with respect to the total number of columns/rows, this requires
      adding to the data definition or to the parameters passed by
      board-ref.

      An alternative fix would be to find a way to give the 1, 1
      number at a different location, so the scheme is like this:

      #+BEGIN_EXAMPLE
             1 2 3 4        number passed to function
             4 3 2 1        number in recursive loop
      1 4 ( (        )
      2 3   (        )
      3 2   (        )
      4 1   (        ) )
      #+END_EXAMPLE
      
      We see a pattern: The number passed to the function is always
      (n+1) - i, where n is the total number of rows or columns and i
      is the index in the recursive loop.

      This doesn't require any extra information to build-board
      althouh it may require reorganization; since build-board takes
      initially the total number of columns and rows. 

      An initial design of build board might go like this:
      #+BEGIN_SRC scheme
      ;; data analysis:
      ;; we are passed two N[>=1].

      ;; build-board : number, number (number number -> piece) -> board
      ;; creates a chessboard that is ixj cells, filling cell i,j with 
      ;; (f i j). 
      (define (build-board i j) ...)
   
      ;; examples:
      (equal? 
       (build-board 1 1 (lambda (i j) 'empty))
       (list (list 'empty)))
      (equal? 
       (build-board 2 2 (lambda (i j) (+ i j)))
       (list (list 2 3
             (list 3 4))))
       
      ;; it seems after a small analysis that the board is made up of two 
      ;; principal aspects corresponding to our two principal inputs:
      ;; 1. columns
      ;; 2. rows.
      ;; in our data definition the total board is made of a list of rows.
      ;; therefore, we should have a function producing a row and another
      ;; producing the board, the row function should be auxiliary. 

      (define (build-board i j f)
        (local ((define (param-num->column# n)
                  (- (+ j 1) n))
                (define (param-num->row# n)
                  (- (+ i 1) n))
                (define (build-board i j m n)
                  (cond
                    ((= i 1) (list (build-row 
                                    j n (lambda (colnum) (f (param-num->row# i) 
                                                            (param-num->column# colnum))))))
                    (else (cons (build-row 
                                 j n (lambda (colnum) (f (param-num->row# i)
                                                         (param-num->column# colnum))))
                                (build-board (sub1 i) j f))))))
           (build-board i j i j f)))

      (define (build-row j f)
        (cond
          ((= j 1) (list (f j)))
          (else (cons (list (f j)) (build-row (sub1 j) f)))))
      #+END_SRC

      After some edits in DrScheme we get:

      #+BEGIN_SRC scheme
      ;; examples:
      
             
      ;; it seems after a small analysis that the board is made up of two 
      ;; principal aspects corresponding to our two principal inputs:
      ;; 1. columns
      ;; 2. rows.
      ;; in our data definition the total board is made of a list of rows.
      ;; therefore, we should have a function producing a row and another
      ;; producing the board, the row function should be auxiliary. 
      
      (define (build-board i j f)
        (local ((define (param-num->column# n)
                  (- (+ j 1) n))
                (define (param-num->row# n)
                  (- (+ i 1) n))
                (define (build-board i j m n)
                  (cond
                    ((= i 1) (list (build-row 
                                    j (lambda (colnum) (f (param-num->row# i) 
                                                            (param-num->column# colnum))))))
                    (else (cons (build-row 
                                 j (lambda (colnum) (f (param-num->row# i)
                                                         (param-num->column# colnum))))
                                (build-board (sub1 i) j m n))))))
          (build-board i j i j)))
      
      (define (build-row j f)
        (cond
          ((= j 1) (list (f j)))
          (else (cons (f j) (build-row (sub1 j) f)))))
      
      (equal? 
       (build-board 1 1 (lambda (i j) 'empty))
       (list (list 'empty)))
      (equal? 
       (build-board 2 2 (lambda (i j) (+ i j)))
       (list (list 2 3)
                   (list 3 4)))
      #+END_SRC

      board-ref can now be a trivial implementation. Because the
      function was passed 1,1 for the (first (first board)) and so on,
      we can do a simple, structurally-recursive implementation of the
      function with no fuss, based on the same pattern.

      #+BEGIN_SRC scheme
      ;; template:
      ;; a board is:
      ;; 1. empty
      ;; 2. (cons board-row board)
     
      ;; a board-row is:
      ;; 1. empty
      ;; 2. (cons piece board-row)

      (define (fun-for-board a-board)
        (cond
          ((empty? a-board) ...)
          (else
           ... (fun-for-row (first a-board)) ...
           ... (fun-for-board (rest a-board)) ...)))

      (define (fun-for-row a-row)
        (cond
          ((empty? a-row) ...)
          (else 
           ... (fun-for-piece (first a-row)) ...
           ... (fun-for-row (rest a-row)) ...)))
      #+END_SRC

      But now we realize that board-ref actually takes two integers in
      addition to a board, so it is consuming two non-complex peices
      of data that are not part of the same data definition, and
      neither of which are static. We can divide ttwo into row-index
      and column-index though, which makes the processing easier: with
      respect to fun-for-board, column-index is static and just a
      parameter to fun-for-row, and fun-for-row doesn't even need to
      know about the row index at all. And we can also see that the
      parameters will vary in lockstep. Nonetheless we will develop a
      table.

      #+BEGIN_SRC scheme
      ;; board-ref : number number board -> piece
      ;; reference a piece in a board by row and column number, indexed
      ;; from 1. 
      (define (board-ref i j a-board) ...)
      
      ;; examples
      (define trivial-board (list (list 1))
      (define board1 (list (list 'empty 'empty)
                           (list 'threatened 'empty)))
      (define board2 (list (list 'empty 'empty 'threatened)
                           (list 'threatened 'empty 'empty)
                           (list 'empty 'threatened 'empty)))
      (equal? (board-ref 1 1 trivial-board) 1)
      (equal? (board-ref 2 1 board1) 'threatened)
      (equal? (board-ref 3 1 board2) 'empty)
      (equal? (board-ref 3 3 board2) 'empty)
      (equal? (board-ref 1 3 board2) 'threatened)
      #+END_SRC

      |                | (= 1 i)                      | (> 1 i)                      |
      | (empty? board) | (and (= 1 i) (empty? board)) | (and (> 1 i) (empty? board)) |
      | (cons? board)  | (and (= 1 i) (cons? board))  | (and (> 1 i) (cons? board))  |

      This same table works for row/j in board-row-ref.

      #+BEGIN_SRC scheme
      (define (board-ref i j a-board)
        (cond
          ((and (= 1 i) (empty? board))
           ...)
          ((and (> i 1) (empty? board))
           ... (board-ref (sub1 i) board) ...)
          ((and (= i 1) (cons? board))
           ... (board-ref i (rest board)) ...)
          ((and (> i 1) (cons? board))
           ... (board-ref (sub1 i) (rest board)) ... ;; OR
           ... (board-ref i (rest board)) ... ;; OR 
           ... (board-ref (sub1 i) board) ...)))
      #+END_SRC

      We can answer that if i == 1 and the board is empty, this should
      be an error, because the 1st index doesn't exist. Next, if i is
      greater than 1 and the board is still emtpy, we should answer
      the same way. And if i is equal to one and the board is a cons,
      we should then process that row.  next item is the recursive
      step that does the magic.

      #+BEGIN_SRC scheme
      (board-ref 2 1 (list (list 'empty 'empty)
                           (list 'threatened 'empty)))
      1. (board-ref 1  1 (1ist (list 'threatened 'empty)))  -> 'threatened ;; correct
          ;; ^^ assumes that the row-referencing worked correctly. 
      2. (board-ref 2 1 (list (list 'threatened 'empty))) -
         (board-ref 2 1 empty) -> error, not correct
      3. (board-ref 1 1 (list (list 'empty 'empty) (list 'threatened 'empty))) -> 'empty ;;incorrect
         ;; ^^ assumes that when we try to reference a column the function works, although
         ;; it's not yet been written.
      #+END_SRC

      It seems recursion (1) is correct.
      #+BEGIN_SRC scheme
      (define (board-ref i j a-board)
        (cond
          ((and (= 1 i) (empty? board))
           (error 'board-ref "board is too small"))
          ((and (> i 1) (empty? board))
           (error 'board-ref "board is too small"))
          ((and (= i 1) (cons? board))
           (board-row-ref j (first board)))
          ((and (> i 1) (cons? board))
           (board-ref (sub1 i) (rest board)))))
      #+END_SRC      

      Now, we need to implement board-row-ref. This will reference a
      column in a row.

      #+BEGIN_SRC scheme
      ;; board-row-ref : number board -> piece 
      ;; indexes the jth column of the board row.
      (define (board-row-ref j a-board-row) ...)

      ;; examples
      (equal? (board-row-ref 3 (list 'empty 'empty 'threatened 'empty))
              'threatened)
      (equal? (board-row-ref 1 (list 'empty))
              'empty)
      ;; error: (board-row-ref 3 (list 'empty))
      ;; error: (board-row-ref 3 (list 'threatened))
      ;; error: (board-row-ref 1 empty)
      #+END_SRC

      The same cases are valid for this function since it also
      processes a list and a number dynamically, so we will fill out
      the template that way. 

      #+BEGIN_SRC scheme
      (define (board-row-ref j a-board-row)
        (cond
          ((and (empty? a-board-row) (= j 1))
           ...)
          ((and (cons? a-board-row) (= j 1))
           ... (board-row-ref j (rest a-board-row)) ...)
          ((and (empty? a-board-row) (> j 1))
           ... (board-row-ref (sub1 j) a-board-row) ...)
          ((and (cons? a-board-row) (> j 1))
           ... (board-row-ref (rest a-board-row) (sub1 j)) ... ;; OR
           ... (board-row-ref a-board-row (sub1 j)) ... ;; OR
           ... (board-row-ref (rest a-board-row) j) ...)))
      #+END_SRC

      for the first case, as per our examples, this should be an
      error. For the second, we should actually take the first
      element of the list, again per the examples. For the third, we
      should signal and error. Finally, we have three types of
      recursion to choose from.

      #+BEGIN_SRC scheme
      1. (board-row-ref 2 (list 'empty 'threatened)) -> 
         (board-row-ref 1 (list 'threatened)) -> 'threatened ;; correct-a-mundo

      2. (board-row-ref 2 (list 'empty 'threatened)) -> p
         (board-row-ref 1 (list 'empty 'threatened)) -> 'empty ;; nope

      3. (board-row-ref 2 (list 'empty 'threatened)) -> 
         (board-row-ref 2 (list 'threatened)) -> 
         (board-row-ref 2 empty) -> error ;; nope
      #+END_SRC

      Recursion (1) works again!

      #+BEGIN_SRC scheme
      (define (board-row-ref j a-board-row)
        (cond
          ((and (empty? a-board-row) (= j 1))
           (error 'board-row-ref "row too small"))
          ((and (cons? a-board-row) (= j 1))
           (first a-board-row))
          ((and (empty? a-board-row) (> j 1))
           (error 'board-row-ref "board row too small"))
          ((and (cons? a-board-row) (> j 1))
           (board-row-ref (sub1 j) (rest a-board-row)))))
      #+END_SRC      

      all tests pass.

    - Exercise 28.2.3. Develop the function threatened?, which
      computes whether a queen can reach a position on the board from
      some given position. That is, the function consumes two
      positions, given as posn structures, and produces true if a
      queen on the first position can threaten the second position.

      *Hint*: the exercise translates the chess problem of
      ``threatening queens'' into the mathematic problem of
      determining whether in some given grid, two positions are on the
      same vertical, horizontal, or diagonal line. Keep in mind that
      each position belongs to two diagonals and that the slope of a
      diagonal is either +1 or -1. 

      We can view this as a simple and: if, by moving in each possible
      direction -  which can be represented by a posn as rise/run - we
      can in any of these directions hit the peice, we're OK. We can
      also simply assert that the peice is within the board dimensions
      and solve an equation:

      #+BEGIN_EXAMPLE
      [q_r + (x*s_r), q_c + (y*s_c)] = [p_r, p_c]
      #+END_SRC
      
      where q_r stands for queen's row, s_r stands for 'slope row',
      i.e. 0, 1, or -1, the slope, and q_c, s_c are the same, and p_r,
      p_c are also the same. Solving this develops the following:

      #+BEGIN_EXAMPLE
      (p_r - q_r) / s_r  = x
      #+END_SRC

      We can see if it an integer by asking whether the remainder
      is 0. If the slope is 0 in a direction, we should test if the
      piece is on the same row/column, if not then return false,
      otherwise true.

      #+BEGIN_SRC scheme
      (define (is-solution? queenpos piecepos slope)
        (and
         (cond
             ((= (posn-x slope) 0) 
              (= (posn-x piecepos) (posn-x queenpos)))
             (else
              (= (remainder (- (posn-x queenpos) (posn-x piecepos))
                       (posn-x slope)) 0)))
         (cond
             ((= (posn-y slope) 0)
              (= (posn-y piecepos) (posn-y queenpos)))
             (else (= (remainder (- (posn-y queenpos) (posn-y piecepos))
                                 (posn-y slope)) 0)))))

      (is-solution? (make-posn 1 1) (make-posn 2 1) (make-posn 1 0))
      (is-solution? (make-posn 1 1) (make-posn 3 3) (make-posn 1 1))
      (not (is-solution? (make-posn 1 1) (make-posn 2 1) (make-posn 0 1)))
      (not (is-solution? (make-posn 2 3) (make-posn 5 9) (make-posn 1 1)))
      (is-solution? (make-posn 5 5) (make-posn 1 1) (make-posn -1 -1))
      (is-solution? (make-posn 20 20) (make-posn 4 4) (make-posn -1 -1))
      (not (is-solution? (make-posn 3 2) (make-posn 1 1) (make-posn -1 -1)))
      #+END_SRC

      There is a solution if any one of the slopes work.

      #+BEGIN_SRC scheme
      (define (threatened? queen piece)
        (or (is-solution? queen piece (make-posn 1 1))
            (is-solution? queen piece (make-posn -1 -1))
            (is-solution? queen piece (make-posn 1 0))
            (is-solution? queen piece (make-posn 0 1))))
      (threatened? (make-posn 50 50) (make-posn 5 5))
      (threatened? (make-posn 100 10) (make-posn 90 10))
      (threatened? (make-posn 60 50) (make-posn 70 50))
      (not (threatened? (make-posn 60 50) (make-posn 1 1)))
      (not (threatened? (make-posn 8 8) (make-posn 2 3)))
      (threatened? (make-posn 10 10) (make-posn 10 0))
      (not (threatened? (make-posn 10 40) (make-posn 9 0)))
      (threatened? (make-posn 5 5) (make-posn 10 10))
      (not (threatened? (make-posn 4 4) (make-posn 5 6)))
      (threatened? (make-posn 5 5) (make-posn 5 5))
      #+END_SRC
      
    Once we have data definitions and functions for the ``language of
    chessboards'', we can turn our attention to the main task: the
    algorithm for placing a number of queens on some given board.

    - Exercise 28.2.4. Develop placement. The function consumes a
      natural number and a board and tries to place that many queens
      on the board. If the queens can be placed, the function produces
      an appropriate board. If not, false.

      One thing we're going to need is a function that takes a list of
      queens with positions already and tries to place them. 

      ;; is-solution? : board (listof posn) -> true or false
      
      Our algorithm is going to have to try every possible placement
      of queens, many queens. However, queens are not distinct. So
      what we really want is an algorithm that generates all possible
      distinct placements of N queens, we need to know when we're done
      trying queens. A placement of queens is a list of posns. No two
      posns will be alike. For each queen placement, a placement of N
      queens is like a placement of N-1 queens, but with another queen
      added to a position in which some queen is not. We can basically
      exhaust a configuration of this by placing the Nth queen in all
      possible positions where another queen isn't for a configuration
      of N-1 queens. The smallest queen configuration is a
      configuration of one queen, and the next configuration for that
      queen is just to move it to the next column or up one row. 

      ;; queen-configuration-generate : board (listof posn ) posn -> (listof
      posn)

      The function generates another configuration of N+1, if (listof
      posn) is N long, with a new queen which _was_ at posn but now is
      at the first element of the returned list.
      
      #+BEGIN_SRC scheme
      ;; all-queen-configurations : board number ->  (listof posn)
      (define (all-queen-configurations board number)
        (cond ((
      ;; queen-configurations : number -> (listof posn)
      (define (queen-configurations board n)
        (cond 
         ((= n 1) (all-queen-configurations board n))
         (else (cons (all-queen-configurations board n)
                     (queen-configurations board (sub1 n))))))
      #+END_SRC
      
      But there is probably a different way. What we can do is try
      smaller and smaller configurations with fewer queens (same board
      size) and try adding a queen. This is more easily recursive.

      1. trivial solution - when there is only a single queen
      2. answer - the queen at whichever position was given is a
         correct solution
      3. making the problem smaller - try to solve a problem with n-1
         queens, then try all possible configurations with another
         queen.
      4. Generation of the new subproblem - simply subtract one from
         the number of queens. Then generate a list of configurations
         with another queen.

      #+BEGIN_SRC scheme
      ;; find-listof-placements : number posn -> (listof posn)
      ;; finds a list of all possible placements for queens on a
      ;; board that is (posn-x b)x(posn-y b).
      (define (find-listof-placements n b)
        (cond ((= n 1) 
               (generate-list-of-all-placements b))
              (else
               (add-one-and-return-possible-solutions 
                (find-listof-placements (sub1 n) b))
                b 
                (make-posn 1 1))))

      ;; add-one-and-return-possible-solutions : (listof posn) posn posn
      ;; given a board b which is (posn-x b)x(posn-y b) and a list of queen positions
      ;; lop and a new queen at queenpos, return all possible additions of a new queen 
      ;; to the board, that is, add all possible queen positions to lop that preserve
      ;; the fact that no queens collide. It is assumed that within lop, no queens collide
      ;; on the board b. 
      (define (add-one-and-return-possible-solutions lop b queenpos)
        (cond
          ((is-queen-on-last-posn? queenpos) empty) ;; last-posn is false.
          (else
           (cond ((queen-works? queenpos lop b) 
                  (cons (cons queenpos lop)
                        (add-one-and-return-possible-solutions 
                         lop b (generate-next-queenpos lop b queenpos))))
                 (else 
                  (add-one-and-return-possible-solutions lop b (generate-next-queenpos lop b queenpos)))))))

      ;; queen-works? (listof posn) posn posn -> true or false
      ;; given a new queen q and an already established list of queen placements
      ;; lop, return true if the new queen q has no collisions with (i.e. does not
      ;; threaten and is not threatened by) other queens on the board in lop.
      (define (queen-works? lop q b) ...)

      ;; generate-next-queenpos : posn posn (listof posn) -> posn or false
      ;; given a current queen position q and board b and a list 
      ;; of established queens q, return the next position on the board
      ;; by incrementing first rows and then columns. returns false
      ;; if q is at the maximum possible position already. 


      ;; is-queen-on-last-posn? : posn or false -> true or false
      ;; returns false if a is a posn, true if it is false, error otherwise.
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (is-queen-on-last-posn? a-posn)
        (boolean? a-posn))

      ;; the current queen position is one of:
      ;; 1. at the end of a row - the 'x', or row, is equal to the board x or nrows.
      ;; 2. between the beginning and end of the row
      ;; 3. false
      (define (generate-next-queenpos board queen)
        (cond
          ((= (posn-y queen) (posn-y board))
           (cond 
             ((= (posn-x queen) (posn-x board)) false)
             (else (make-posn (+ (posn-x queen) 1) 1))))
          ((boolean? queen) queen)
          (else (make-posn (posn-x queen) (+ 1 (posn-y queen))))))
                              
      (equal? (generate-next-queenpos (make-posn 2 2) (make-posn 1 1))
              (make-posn 1 2))
      (equal? (generate-next-queenpos (make-posn 2 2) (make-posn 1 2))
              (make-posn 2 1))
      (equal? (generate-next-queenpos (make-posn 2 2) (make-posn 2 1))
              (make-posn 2 2))
      (equal? (generate-next-queenpos (make-posn 2 2) (make-posn 2 2))
              false)
      #+END_SRC

      #+BEGIN_SRC scheme
      ;; queen-works? (listof posn) posn posn -> true or false
      ;; given a new queen q and an already established list of queen placements
      ;; lop, return true if the new queen q has no collisions with (i.e. does not
      ;; threaten and is not threatened by) other queens on the board in lop.
      (define (queen-works? lop q b) ...)

      (equal? 
       (queen-works? (list (make-posn 4 4)) (make-posn 2 2) (make-posn 8 8))
       false)
      (equal? 
       (queen-works? (list (make-posn 4 4)) (make-posn 5 6) (make-posn 8 8))
       true)
      (equal? 
       (queen-works? (list (make-posn 4 4) (make-posn 5 5)) 
                     (make-posn 5 6)
                     (make-posn 8 8))
       false)
      (equal? 
       (queen-works? empty (make-posn 2 2) (make-posn 8 8))
        true)

      ;; we can see quickly a simple solution:
      (define (queen-works? lop q b)
        (andmap (lambda (a-queen) (threatened? q a-queen)) lop))

      (define (generate-list-of-all-placements b)
        (local ((define (generate-list-of-all-placements b q)
                  (cond 
                    ((is-queen-on-last-posn? q) empty)
                    (else (cons q (generate-list-of-all-placements b (generate-next-queenpos q)))))))
          (generate-list-of-all-placements b (make-posn 1 1)))) 
      #+END_SRC
      
      

    




      



      
      

      
      

