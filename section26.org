* Section 26
** Designing Algorithms
   At first glance, the algorithms move-until-out and quick-sort have
   little in common. Once processes structures; the other processes
   lists. One creates new structure for the generative step; the other
   splits up a list into three pieces and recurs on two of them. In
   short, a comparison of the two examples of generative recursion
   suggests that it is impossible to come up with a general design
   recipe. A closer look, however, suggests a different picture. 

   First, even though we speak of algorithms as processes that solve
   problems, they are still functions that consume and produce
   data. In other words, we still choose data to represent a problem,
   and we must definitely understand the nature of our data if we wish
   to understand the process. Second, we describe the processes in
   terms of data, for example, ``creating a new structure'' or
   ``partitioning a list of numbers.'' Third, we always distinguish
   between input data for which it is trivial to produce a solution
   and those for which it is not. Fourth, the generation of problems
   is the key to the design of algorithms. Although the idea of how to
   generate a new problem might be independent of a data
   representation, it must certainly be implemented in whatever form
   of representation we choose for our problem. Finally, once the
   generated problems have been solved, the solutions must be combined
   with other values.

   Let us examine the six general stages of our structural design
   recipe in light of our discussion:

   - Data analysis and design ::
	The choice of a data representation for a problem often
        affects our thinking about the process. Sometimes the
        description of a problem dictates a particular choice of
        representation. On other occasions it is possible and
        worthwhile to explore alternatives. In any case we must
        analyze and define our data collections.
   - Contract, purpose, header :: 
	We also need a contract, a definition header, and a purpose
        statement. Since the generative step has no connection to the
        structure of the data definition, the purpose statement should
        not only specify *what* the function does but should also
        include a comment that explains in general terms *how* it
        works.
   - Function examples :: 
	In our previous design recipes, the function examples merely
        specified which output the function should produce for some
        given input. For algorithms, examples should illustrate *how*
        the algorithm proceeds for some given input. This helps us to
        design, and readers to understand, the algorithm. For
        functions such as move-until-out the process is trivial and
        doesn't need more than a few words. For others, including
        quick-sort, the process relies on a non-trivial idea for its
        generative step, and its explanation requires a good example
        such as the one in figure 67.
   - Template :: 
        Our discussion suggests a general template for algorithms:

	#+BEGIN_SRC scheme
	(define (generative-recursive-fun problem)
	  (cond
            [(trivially-solvable? problem)
	     (determine-solution problem)]
            [else
             (combine-solutions
	      ... problem ...
              (generative-recursive-fun (generate-problem-1 problem))
              .
              .
              .
              (generate-recursive-fun (generate-problem-n
                 problem)))]))
        #+END_SRC
   - Definition :: 
       Of course, this template is not only a suggestive blueprint,
       not a definitive shape. Each function in the template is to
       remind us that we need to think about the following four
       questions: 
     1. What is a trivially solvable problem?
     2. what is the corresponidng solution?
     3. How do we generate new problems that are more easily solvable
        than the original problem? Is there one new problem that we
        generate or are there several?
     4. Is the solution of the given problem the same as the solution
        of (one of) the new problems? Or, do we need to combine the
        solutions to create a solution for the original problem? And
        if so, do we need anything from the original problem data?
     To define the algorithm, we must express the answers to these
     questions in terms of chosen data representation.
   - Test :: 
      Once we have a complete function we must also test it. As
      before the goal of testing is to discover bugs and eliminate
      them. Remember that testing cannot validate that the function
      works correctly for all possible inputs. Also remember that it
      is best to formulate tests as boolean-valued expressions that
      automatically compare the expected value with the compound
      value (see section 17.8).

   - Exercise 26.0.7. Formulate informal answers to the four key
     questions for the problem of modeling a ball's movement across a
     canvas until it is out of bounds.
     1. What is the trivially solvable problem? -- a ball which is out
        of the bounds of the canvas, that is, has an x or y position
        which are less than 0 or an x or y position greater than the x
        or y boundaries, respectively. In this case we simply return
        true.
     2. What is the corresponding solution? -- for an out of bounds
        ball, the value true.
     3. How do we generate new problems that are more easily solvable
        than the original problem? Is there one new problem that we
        generate or are there several? -- The new problem is the ball
        which as been moved, which is presumably closer to being out
        of bounds and therefore closer to being trivially solvable.
     4. Is the solution of the given problem the same as the solution
        of (one of) the new problems? Or, do we need to combine the
        solutions to create a solution for the original problem? And
        if so, do we need anything from the original problem data? --
        The answer to the new, smaller problem is the same as the
        answer to the larger problem.
   - Exercise 26.0.8. Formulate informal answers to the four key
     questions for the quick-sort problem. How many instances of
     generate-problem are there?
     1. What is a trivially solvable problem? -- the sorted empty list
        is empty, so this is the trivially solvable problem.
     2. What is a corresponding solution? -- empty.
     3. How do we generate new problems that are more easily solvable
        than the original problem? Is there one new problem that we
        generate or are there several? -- We generate new problems by
        taking out the first element of the list and partitioning the
        list into two (unsorted) lists - one which has items strictly
        less than, and one with items greater than or equal to but not
        including the first item in the list. Thus, both lists are
        strictly smaller than the input list, the total length of both
        is exactly one less. So, we have two new smaller problems, we
        sort the list of items smaller than the first item, and the
        list of items greater than the first item, then append
        them. So generally speaking it is easier because the sublists
        are smaller than the input list and therefore closer to being
        empty which is the trivially solvable solution.
     4. Is the solution of the given problem the same as the solution
        of (one of) the new problems? Or, do we need to combine the
        solutions to create a solution for the original problem? And,
        if so, do we need anything from the original problem data? --
        The solution to the two sub-problems is not in fact the
        same. Each sub-problem returns a sorted list which contains
        elements from the total sorted list but we need to combine the
        two solutions with the piece of data we took from the list
        into a new total list. We need the first element of the
        original problem, which will not be present in either solution
        to the new, smaller, sub-problems.
** 26.1 Termination
   Unfortunately, the standard recipe is not good enough for the
   design of algorithms. Up to now, a function has always produced an
   output for any legitimate input. That is, the evaluation has always
   stopped. After all, by the nature of our recipe, each natural
   recursion consumes an immediate piece of the input, not the input
   itself. Because data is constructed in a hierarchical manner, this
   means that the input shrinks at every stage. Hence the function
   sooner or later consumes an atomic piece of data and stops.

   With functions based on generative recursion, this is no longer
   true. The internal recursions don't consume an immediate component
   of the input but some new piece of data, which is generated from
   the input. As exercise 25.1.1 shows, this step may produce the
   input over and over again and thus prevent the evaluation from ever
   producing a result. We say that the program LOOPS or is in an
   INFINITE LOOP. 

   In addition, even the slightest mistake in translating the process
   description into a function definition may cause an infinite
   loop. The problem is most easily understood with an
   example. Consider the following definition of smaller-items, one of
   the two ``problem generators'' for quick-sort:

   #+BEGIN_SRC scheme
   ;; smaller-items : (listof number) number -> (listof number)
   ;; to create a list with all those numbers on alon
   ;; that are smaller than or equal to threshold.
   (define (smaller-items alon threshold)
     (cond
       [(empty? alon) empty]
       [else (if (<= (first alon) threshold)
                 (cons (first alon) (smaller-items (rest alon) threshold))
		 (smaller-items (rest alon) threshold))]))
   #+END_SRC

   Instead of < it employs <= to compare numbers. As a result this
   function produces (list 5) when applied to (list 5) and 5.

   Worse, if the quick-sort function from figure 68 is combined with
   this new version of smaller-items, it doesn't produce any output
   for (list 5):

   #+BEGIN_SRC scheme
     (quick-sort (list 5))
   = (append (quick-sort (smaller-items 5 (list 5)))
             (list 5)
	     (quick-sort (larger-items 5 (list 5))))
   = (append (quick-sort (list 5))
             (list 5)
             (quick-sort (larger-items 5 (list 5))))
   #+END_SRC

   The first recursive use demands that quick-sort solve the problem
   of sorting (list 5) -- but that is the exact problem that we
   started with. Since this is a circular evaluation, (quick-sort
   (list 5)) never produces a result. More generally there is no
   guarantee that the size of the input for a recursive call brings us
   closer to a solution that the original input.

   | Phase    | Goal                                                                                     | Activitiy                                                                                                                                                                                                                                                                                    |
   |----------+------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | Examples | To characterize the input-output relationship and the computational process via examples | create and show examples of trivially solvable problems * create and show examples that require recursive processing * illustrate how to work through examples                                                                                                                               |
   | Body     | To define an algorithm                                                                   | formulate tests for trivially solvable problems * formulate answers for the trivial cases * determine how to generate new problems from teh given problem, possibly using auxiliary functions * determine how to combine the solutions of the problems into a solution for the given problem |
   | Termin.  | To argue that the algorithm terminates for all possible inputs                           | shows that the inputs to the recursive applications are smaller than the given input                                                                                                                                                                                                         |

   The lesson from this example is that the design of algorithms
   requires one more step in our design recipe: a TERMINATION
   ARGUMENT, which explains why the process produces an output for
   every input and how the function implements this idea; or a
   warning, which explains when the process may not terminate. For
   quick-sort, the argument might look like this:

   At each step, quick-sort partitions the list into two sublists
   using smaller-items and larger-items. Each function produces a list
   that is smaller than the input (the second argument), even if the
   threshold (the first argument) is an item on the list. Hence each
   recursive application of quick-sort consumes a strictly shorter
   list than the given one. Eventually, quick-sort receives and
   returns empty.

   Without such an argument an algorithm must be considered
   incomplete.

   A good termination argument may on occasion also reveal additional
   termination cases. For example, (smaller-items N (list N)) and
   (larger-items N (list N)) will always produce empty for any
   N. Therefore we know that quick-sort's answer for (list N) is (list
   N). To add this knowledge to quick-sort, we simply add a
   cond-clause:

   #+BEGIN_SRC scheme
   (define (quick-sort alon)
     (cond
       [(empty? alon) empty]
       [(empty? (rest alon)) empty]
       [else (append
              (quick-sort (smaller-items alon (first alon)))
	      (list (first alon))
	      (quick-sort (larger-items alon (first alon))))]))
   #+END_SRC
   
   The condition (empty? (rest alon)) is one way to ask whether alon
   contains one item.

   #+BEGIN_SRC scheme
   ;; tabluate-div : N[>=1] -> (listof N[>=1])
   ;; return a list in ascending order of all the divisors of n.
   (define (tabluate-div n) ...)
   #+END_SRC

   Examples:
   #+BEGIN_SRC scheme
   (equal? (tabluate-div 4) (list 1 2 4))
   (equal? (tabluate-div 6) (list 1 2 3 6))
   (equal? (tabluate-div 5) (list 1 5))
   #+END_SRC

   #+BEGIN_SRC scheme
   (define (tabulate-div n)
     (cond
       ((= 1 n) (list 1))
       (else
         (combine ...
	   ... n ...
           (tabluate-d-v (generate-subproblem-1 n))
	   ...
	   (tabluate-div (generate-subproblem-n n))
           n))))
   #+END_SRC

   We know: 
   - one divisor in the list is n.
   - if n is 1, that is the only item in the list.

   The simplest way to find a single divisor is to count down by ones:

   #+BEGIN_SRC scheme
   ;; greatest-divisor : N[>=1] -> N[>=1]
   ;; find the largest number that divides n.
   (define (greatest-divisor n) ...)
   #+END_SRC
   
   Template:

   #+BEGIN_SRC scheme
   (define (greatest-divisor n)
     (cond ((= n 1) ...)
           (else ... n ... (greatest-divisor (sub1 n)))))
   #+END_SRC

   the answer for (= n 1) should be 1. 

   We can clearly see that if (remainder n some-value) is 0 we should
   return that value, but...

   There's a problem: if greatest divisor is called with (sub1 n) and
   nothing else, we have no way of knowing what our original number
   was. So we will define an auxiliary greatest-divisor that takes n
   and the current attempt at dividing. n will be the same, but
   atomic. d will be the current attempt at dividing. 

   (define (greatest-divisor n)
     (local ((define (greatest-divisor n d)
               (cond ((= d 1) 1)
                     (else (if (= (remainder n d) 0)
                                  d
                                  (greatest-divisor n (sub1 d)))))))
      (greatest-divisor n (sub1 n))))

   #+BEGIN_SRC scheme
   (define (greatest-divisor n)
     (local ((define (greatest-divisor n current)
               (cond ((= 1 current) 1)
                     (else (if (= (remainder n current) 0) 
                               current
			       (greatest-divisor n (sub1 current)))))))
      (greatest-divisor n (sub1 n))))
   #+END_SRC
   
   We can use this as an item in the list and as input to the next problem.

   #+BEGIN_SRC scheme
   (define (tabluate-div n d)
     (cond
       ((= d 1) (list 1))
       ((= (remainder n d) 0)
        (append (tabluate-div n (sub1 d))
                (list d)))
       (else (tabluate-div n (sub1 d)))))
   #+END_SRC

   Questions
   Redo:

   We did the contract and purpose header as well as the template. 
   
   Definition:
   1. What is the trivially solvable problem? The list of divisors of
      1 is (list 1).
   2. What is the corresponding solution? (list 1).
   3. How do we generate new problems that are more easily solvable
      than the original problem? Is there one new problem that we
      generate or are there several? -- we generate new problems by
      making the number smaller and closer to one each time. We can do
      this by subtracting 1 from the attempted divisor at each
      step. If the attempted divisor 'works', i.e. n is divisible by
      it, we add it to the list, and continue tabulating. Otherwise,
      continue trying to tabulate without adding it to the list.

   #+BEGIN_SRC scheme
   ;; tabulate-div : N[>=1] -> (listof N[>=1])
   (define (tabulate-div n)
     (local ((define (tabulate-div n d)
               (cond ((= d 1) 1)
                     ((= (remainder n d) 0) 
                      (cons d (tabluate-div n (sub1 d))))
                     (else (tabulate-div n (sub1 d))))))
       (tabluate-div n n)))
   #+END_SRC

   This is really just structural, plus the earlier questions we had.
   
   - Exercise 26.1.2. Develop the function merge-sort, which sorts a
     list of numbers in ascending order, using the following two
     auxiliary functions:

     1. The first one, make-singles, constructs a list of one-item
        lists from the given list of numbers. For example:

	#+BEGIN_SRC scheme
	(equal? (make-singles (list 2 5 9 3))
                (list (list 2) (list 5) (list 9) (list 3)))
        #+END_SRC

     2. The second one, merge-all-neighbors, merges pairs of
        neighboring lists. More specifically it consumes a list of
        lists (of numbers) and merges neighbors. For example,

	#+BEGIN_SRC scheme
	(equal? (merge-all-neighbors (list (list 2)
                                           (list 5)
                                           (list 9)
                                           (list 3)))
                (list (list 2 5) (list 3 9)))
        (equal? (merge-all-neighbors (list (list 2 5) (list 3 9)))
                (list (list 2 3 5 9)))
        #+END_SRC

        In general, this function yields a list that is approximately
        half as long as the input. Why is the output not always half
        as long as the input?

     3. make-singles
	
	;; make-singles : (listof number) -> (listof (cons number  empty))
	;; makes a list of lists where each list contains a single number,
	;; the numbers are the same as the input list just nested a layer deep.

	(equal? (make-singles empty) empty)
	(equal? (make-singles (list 1)) (list (list 1)))
	(equal? (make-singles (list 1 2)) (list (list 1) (list 2)))
	
	template:
	#+BEGIN_SRC shceme
	(define (make-singles alon)
          (cond ((empty? alon) ...)
	        (else ... (first alon) ...
                      ... (make-singles (rest alon)) ...)))
        #+END_SRC

        definition:
	#+BEGIN-SRC scheme
	(define (make-singles alon)
          (cond ((empty? alon) empty)
                (else (cons (cons (first alon) empty)
                            (make-singles (rest alon))))))
        #+END_SRC

     4. merge-all-neighbors
	;; merge-all-neighbors : (listof (listof number)) -> (listof (listof number))
	;; take a list of lists, each of which is either single or ordered. 
	;; Merge each neighbor, starting with 1 and 2, such that the result is a list
	;; of lists that is half or half+1 the length of the input list, 
	;; and each inner list is still in sorted order. 
	(define (merge-all-neighbors alolon) ...)

	(equal? (merge-all-neighbors empty) empty)
	(equal? (merge-all-neighbors (list (list 1))) (list (list 1)))
	(equal? (merge-all-neighbors (list (list 2) (list 1))) (list (list 1 2)))
	(equal? (merge-all-neighbors (list (list 3) (list 2) (list 1)))
                (list (list 2 3) (list 1)))
	(equal? (merge-all-neighbors (list (list 2 3) (list 1))) (list (list 1 2 3)))

        Template:
	#+BEGIN_SRC scheme
	(define (merge-all-neighbors alolon)
          (cond
            ((empty? alolon) ...)
	    (else ... (first alolon) ...
	          ... (merge-all-neighbors (rest alolon)) ...)))

        #+END_SRC

        The answer to the first clause is clearly empty. Next, we see
        that we want to access two items at a time. We would be better
        served by a different data definition that takes into account
        the purpose of our function and of the list, how we look at it
        when we consider what we want to do with it.

	a list-of-neighbors is:

	1. empty
	2. (cons x empty) where x is a (listof number)
	3. (cons x (cons y l)) where x and y are (listof number) and l
           is a list-of-neighbors.

        This gives us a new template based on this data definition:

	#+BEGIN_SRC scheme
	(define (merge-all-neighbors alolon)
	  (cond 
            ((empty? alolon) ...)
	    ((empty? (rest alolon)) ...)
	    (else
	      ... (first alolon) ...
	      ... (first (rest alolon)) ...
	      ... (merge-all-neighbors (rest (rest alolon))) ...)))
        #+END_SRC

        Now we can define our function with more ease. Based on the
        examples the first two clauses should return empty and alolon,
        respectively. The next clause should merge the first two
        lists, preserving order, and the recursive call takes care of
        the rest of the list. Clearly, we need an auxiliary function,
        merge. 

	#+BEGIN_SRC scheme
	(define (merge-all-neighbors alolon)
	  (cond 
            ((empty? alolon) empty)
	    ((empty? (rest alolon)) alolon)
	    (else
              (cons 
	       (merge (first alolon)
	              (first (rest alolon)))
	       (merge-all-neighbors (rest (rest alolon)))))))
        #+END_SRC		

        merge takes two complex inputs, it needs the more complex
        recipe. 

	#+BEGIN_SRC scheme
	;; merge : (listof number) (listof number) -> (listof number)
	;; combines two already sorted lists, preserving the order of
        ;; them.
	(define (merge alon1 alon2) ...)

	(equal? (merge (list 1) (list 1)) (list 1 1))
	(equal? (merge (list 1) empty) (list 1))
	(equal? (merge (list 1 2) (list 3 4)) (list 1 2 3 4))
	(equal? (merge empty (list 3 4)) (list 3 4))
	(equal? (merge (list 1 5 7) (list 2 4 6)) (list 1 2 4 5 7))
	#+END_SRC

	Template:
	We need to look at our data definition:
	
	a (listof number) is:
	1. empty
	2. (cons n lon) where n is a number and lon is a (listof
           number).

	We therefore need to take into account different possible
        clauses:

	|                | (empty? alon1)                      | (cons? alon1)                      |
	|----------------+-------------------------------------+------------------------------------|
	| (empty? alon2) | (and (empty? alon1) (empty? alon2)) | (and (cons? alon1) (empty? alon2)) |
	| (cons? alon2)  | (and (empty? alon1) (cons? alon2))  | (and (cons? alon1) (cons? alon2))  |

	We can then create a generic template, annotated with possible
        recursions:

	#+BEGIN_SRC scheme
	(define (merge alon1 alon2)
	  (cond
	    ((and (empty? alon1) (empty? alon2))
             ...)
            ((and (empty? alon1) (cons? alon2))
	     ... (first alon2) ...
	     ... (merge (rest alon2) alon1) ...
             ... (merge alon1 (rest alon2)) ...)
            ((and (cons? alon1) (empty? alon2))
	     ... (first alon1) ...
             ... (merge alon2 (rest alon1)) ...
	     ... (merge (rest alon1) alon2) ...)
            ((and (cons? alon1) (cons? alon2))
	     ... (first alon1) ...
	     ... (first alon2) ...
	     ... (merge-sort (rest alon1) (rest alon2)) ...
	     ... (merge-sort alon1 (rest alon2)) ...
	     ... (merge-sort (rest alon1) alon2) ...
             ... (merge-sort (rest alon2) (rest alon1)) ...
	     ... (merge-sort alon2 (rest alon1)) ... )))
        #+END_SRC
	     
        Plainly, the first answer should be empty. For the second
        question, we can see from the examples that returning the
        non-empty list makes the most sense, and likewise for the
        third clause. The difficulty is in the final clause. There are
        two possible inputs:

	1. where (first alon1) is greater than or equal to (first alon2), and
           should appear after it in the output data.

	   1. (merge (list 2) (list 1))
	      - (merge-sort (rest alon1) (rest alon2)) --
	        (merge empty empty) --> empty/some sorted list.
		MAYBE since it depends on how we combine outputs. 
	      - (merge-sort alon1 (rest alon2)) --
	        (merge (list 2) empty) -- (list 2) -- this depends on
                 how we combine the output. We could do (cons (first
                 alon1) (merge alon1 (rest alon2)). This would be
                valid. MAYBE.
	      - (merge-sort (rest alon1) alon2) 
		(merge-sort emtpy (list 1)) -- this would return (list
                1), and again, it depends on how the output is
                combined. We could do (append alon1 (merge-sort empty
                alon2)) MAYBE.
	      - (merge-sort (rest  alon2) (rest alon2)) -- again,
                merge sorting this way is an empty result and we could
                combine in a number of ways.
	      - (merge-sort alon2 (rest alon1)) -- 
		(merge-sort (list 2) empty) -- (list 2) - could be
                combined so it works MAYBE.
		
	   2. (merge (list 2 3 4) (list 1))
	      - (merge (rest alon1) (rest alon2)) --
		(merge (list 3 4) empty) -- (list 3 4). We could then
                combine like this: 

                (cons (first alon2) (cons (first
                  alon1) (merge (rest alon1) (rest alon2)). 
                MAYBE.

	   3. (merge (list 2 3 4 5) (list 1 1 50 60))
	      - (merge (rest alon1) (rest alon2)) --
		(merge (list 3 4 5) (list 1 50 60)) -- If this call
                returns correctly, we still can't combine them
                effectively. It would return (list 1 3 4 5 50 60), we
                would need to insert 2 after the 1. so NO in cases
                where they are not equal. We could combine it well if
                we gave (rest alon2) as input data and alon1 as data
                to the function -- in cases where (first alon1) >
                (first alon2). 

		(cond ((> (first alon1) (first alon2))
                       (cons (first alon2) (merge alon1 (rest
                alon2))))
                      ((< (first alon1) (first alon2))
                       (cons (first alon1) (merge (rest alon1)
                alon2)))
                      ((= (first alon1) (first alon2))
                       (cons (first alon1) (cons (first alon2) (merge
                (rest alon1) (rest alon2))))))

	   4. (merge (list 2 2 3 4) (list 

	2. where (first alon1) is less than (first alon2), and should
           appear before. 

	#+BEGIN_SRC scheme
	(define (merge alon1 alon2)
	  (cond
	    ((and (empty? alon1) (empty? alon2))
             empty)
            ((and (empty? alon1) (cons? alon2)) alon2)
	    ((and (cons? alon1) (empty? alon2)) alon1)
	    ((and (cons? alon1) (cons? alon2))
	     (cond
	       ((< (first alon1) (first alon2))
	        (cons (first alon1) (merge (rest alon1) alon2)))
	       ((> (first alon1) (first alon2))
	        (cons (first alon2) (merge alon1 (rest alon2))))
	       ((= (first alon1) (first alon2))
		(cons (first alon1)
                      (cons (first alon2) (merge (rest alon1) (rest
        alon2)))))))))
        #+END_SRC

	#+BEGIN_SRC scheme
	(define (merge-singles alos)
	 (cond ((empty? (rest alon)) (first alon))
	       (else (merge-singles (merge-all-neighbors alon)))))
        (define (merge-sort alon)
          (merge-singles (make-singles alon)))
	#+END_SRC
** Structural versus Generative Recursion
   The template for algorithms is so general that it even covers
   functions based on structural recursion. Consider the version with
   one termination clause and one generation step:

   #+BEGIN_SRC scheme
   (define (generative-recursive-fun problem)
     (cond
       [(trivially-solvable? problem)
        (determine-solution problem)]
       [else
        (combine-solutions
	 problem
	 (generative-recursive-fun (generate-problem problem)))]))
    #+END_SRC

    - Exercise 26.2.1. Define determine-solution and combine-solutions
      so that the function generative-recursive-fun computes the
      length of its input.

      #+BEGIN_SRC scheme
      (define (determine-solution a-problem) 0)
      
      (define (combine-solution a-problem solved-subproblem)
        (+ 1 solved-subproblem))
      
      (define (generative-recursive-fun problem)
        (cond
          [(empty? a-problem) (determine-solution problem)]
          [else
           (combine-solutions
            problem
            (generative-recursive-fun (rest problem)))]))
       #+END_SRC

    This discussion raises the question of whether there is a
    difference between functions based on structural recursion and
    those based on generative recursion. The answer is ``it depends.''
    Of course we could say that all functions using structural
    recursion are just special cases of generative recursion. This
    ``everything is equal'' attitude, however, is of no help if we
    wish to understand the process of designing functions. It confuses
    two classes of functions that are designed with different
    approaches and that have different consequences. One relies on a
    systematic data analysis and not much more; the other requires a
    deep, often mathematical, insight into the problem-solving process
    itself. One leads programmers to naturally terminating functions;
    the other requires a termination argument. 

    A simple inspection of a function's definition quickly shows
    whether a function uses structural or generative recursion. All
    self-applications of a structurally recursive function always
    receive an immediate component of the current input for further
    processing. For example, for a constructed list, the immediate
    components are the first item and the rest of the constructed
    list. Hence, if a function consumes a plain list and its recursive
    use does not consume the rest of the list, its definition is not
    structural but generative. Or, put positively, properly recursive
    algorithms consume newly generated input, which may or may not
    contain components of the input. In any case, the new piece of
    data represents a different problem than the given one, but still
    a problem of the same general class of problems. 

** 26.3    Making Choices
   A user cannot distinguish sort and quick-sort. Both consume a list
   of numbers; both produce a list that consists of the same numbers
   arranged in ascending order. To an observer, the functions are
   completely equivalent. This raises the question of which of the two
   a programmer should provide. More generally, if we can develop a
   function using structural recursion and an equivalent one using
   generative recursion, what should we do?

   To understand this choice better, let's discuss another classical
   example of generative recursion from mathematics: the problem of
   finding the greatest common divisor of two positive natural
   numbers. All such numbers have at least one divisor in
   common: 1. On occasion, this is also the only common divisor. For
   example, 2 and 3 have only 1 as common divisor because 2 and 3,
   respectively, are the only other divisors. Then again, 6 and 25 are
   both numbers with several divisors:

   1. 6 is evenly divisible by 1, 2, 3, and 6;
   2. 25 is evenly divisible by 1, 5, and 25. 

   Still, the greatest common divisor of 25 and 6 is 1. In contrast,
   18 and 24 have many common divisors:

   1. 18 is evenly divisible by 1, 2, 3, 6, 9, and 18;
   2. 24 is evenly divisible by 1, 2, 3, 4, 6, 8, 12, and 24.

   The greatest common divisor is 6. 

   Following the design recipe, we start with a contract, a purpose
   statement, and a header:

   #+BEGIN_SRC scheme
   ;; gcd : N[>= 1] N[>= 1] -> N
   ;; to find the greatest common divisor of n and m
   (define (gcd n m)
    ...)
   #+END_SRC

   The contract specifies the precise inputs: natural numbers that are
   greater or equal to 1 (not 0).
   
   Now we need to make a decision whether we want to pursue a design
   based on structural or on generative recursion. Since the answer is
   by no means obvious, we develop both. For the structural version,
   we must consider which input the function should process: n, m, or
   both. A moment's consideration suggests that what we really need is
   a function that starts with the smaller of the two and outputs the
   first number smaller or equal to this input that evenly divides
   both n and m.

   #+BEGIN_SRC scheme
   ;; gcd-structural : N[>=1] N[>=1] -> N
   ;; to find the greatest common divisor of n and m
   ;; structural recursion using data definition of N[>=1].
   (define (gcd-structural n m)
     (local ((define (first-divisor-<= i)
               (cond
	         [(= i 1) 1]
		 [else (cond
		         [(and (= (remainder n i) 0)
			       (= (remainder m i) 0)) i]
			 [else (first-divisor-<= (- i 1))])])))
        (first-divisor-<= (min m n))))
   #+END_SRC

   We use *local* to define an appropriate auxiliary function: see
   figure 70. The conditions ``evenly divisible'' have been encoded as
   (= (remainder n i) i) and (= (remainder m i) 0). The two ensure
   that i divides n and m without a remainder. Testing gcd-structural
   with examples shows that it finds the expected answers.

   Although the design of gcd-structural is rather straightforward, it
   is also naive. It simply tests for every number whether it divides
   both n and m evenly and returns the first such number. For small
   natural numbers, this process works just fine. Consider the
   following example, however:

   (gcd-structural 101135853 45014640)

   The result is 177 and to get there gcd-structural had to compare
   101135676, that is, 101135853 - 117, numbers. This is a large
   effort and even reasonably fast computers spend several minutes on
   this task.

   - Exercise 26.3.1. Enter the definition of gcd-structural into the
     Definitions window and evaluate (time (gcd-structural 101135853
     45014640)) in the Interactions window.

    Since mathematicians recognized the inefficiency of the
    ``structural algorithm'' a long time ago, they studied the
    problem of finding divisors in more depth. The essential insight
    is that for two natural numbers larger and smaller, the greatest
    common divisor is equal to the greatest common divisor of smaller
    and the remainder of larger divided into smaller. Here is how we
    can put this insight into equational form:
     
       (gcd larger smaller)
     = (gcd smaller (remainder larger smaller))

     Since (remainder larger smaller) is smaller than both larger and
     smaller, the right-hand side use of gcd consumes smaller first. 

     Here is how this insight applies to our small example:

     1. The given numbers are 18 and 24

     2. According to the mathematician's insight, they have the same
        greatest common divisor as 18 and 6.

     3. And these two have the greatest common divisor as 6 and 0. 

     And here we seem stuck because 0 is nothing expected. But, 0 can
     be evenly divided by every number, so we have found our
     answer: 6. 

     Working through the example not only explains the idea but also
     suggests how to discover the case with a trivial solution. When
     the smaller of the two numbers is 0, the result is the larger
     number. Putting everything together, we get the following
     definition:

     #+BEGIN_SRC scheme
     ;; gcd-generative : N[>= 1] N[>=1] -> N
     ;; to find the greatest common divisor of n and m
     ;; generative recursion: (gcd n m) = (gcd n (remainder m n)) if
     ;; (<= m n)
     (define (gcd-generative n m)
     (local ((define (clever-gcd larger smaller
     (cond
     [(= smaller 0) larger]
     [else (clever-gcd smaller (remainder larger
     smaler))]))))
     (clever-gcd (max m n) (min m n))))
     #+END_SRC

     The local definition introduces the workhorse of the function:
     clever-gcd, a function based on generative recursion. Its first
     line discovers the trivially solvable case by comparing smaller
     to 0 and produces the matching solution. The generative step uses
     smaller as the new first argument and (remainder larger smaller)
     as the new second argument to clever-gcd, exploiting the above
     equation. 

     If we now use gcd-generative with our complex example from above:

     (gcd-generatie 101135853 45014640)

     we see that the response is nearly instantaneous. A
     hand-evaluation shows that clever-gcd recurs only nine times
     before it produces the solution: 177. In short, generative
     recursion has helped find us a much faster solution to our
     problem.

     - Exercise 26.3.2. Formulate informal answers to the four key
       questions for gcd-generative.

       Four key questions:

       1. What is a trivially solvable problem?
	  A trivially solvable problem is a problem where one of the
          numbers - the smaller - is 0. Then the GCD is the larger
          number since 0 is divisible by anything.

       2. What is the corresponding solution? the larger number.

       3. How do we generate new problems that are more easily
          solvable than the original problem? Is there one new problem
          that we generate or are there several? 

	  We generate a new problem by finding the remainder of larger
          and smaller. Then we solve the gcd of the remainder, and
          smaller. 

       4. Is the solution of the given problem the same as the
          solution of (one of) the new problems? Or, do we need to
          combine the solutions to create a solution for the original
          problem? And, if so, do we need anything from the original
          problem data?

          We do not need to combine the solutions. The solution we 
          find if smaller is 0 is the entire solution.

     - Exercise 26.3.3. Define gcd-generative and evaluate
       
       (time (gcd-generative 101135853 45014640))
       
       in the INteractions window.

       Evaluate (clever-gcd 101135853 45014640) by hand. Show only
       those lines that introduce a new recursive call to clever-gcd.

       #+BEGIN_SRC scheme
       (define (clever-gcd m n)
         (local ((define (clever-gcd larger smaller)
                   (cond
                     [(= smaller 0) larger]
                     [else (clever-gcd smaller (remainder larger smaller))])))
           (clever-gcd (max m n) (min m n))))

         (clever-gcd 101135853 45014640)
       = (local ((define (clever-gcd larger smaller)
                   (cond 
                     [(= smaller 0) larger]
                     [else (clever-gcd smaller (remainder larger smaller))])))
           (clever-gcd (max 101135853 ) (min 101135853 45014640)))
       = (local ((define (clever-gcd_0 larger smaller)
                   (cond 
                     [(= smaller 0) larger]
                     [else (clever-gcd_0 smaller (remainder larger smaller))])))
           (clever-gcd_0 (max 101135853 45014640) (min 101135853 45014640)))
       = (define (clever-gcd_0 larger smaller)
           (cond
             [(= smaller 0) larger]
             [else (clever-gcd_0 smaller (remainder larger smaller))]))
       (clever-gcd_0 (max 101135853 45014640) (min 101135853 45014640))
       = (clever-gcd_0 101135853 45014640)
       = (cond
           [(= 45014640 0) 101135853]
           [else (clever-gcd_0 45014640 (remainder 101135853 45014640))])
       = (cond
           [false 101135853]
           [else (clever-gcd_0 45014640 (remainder 101135853 45014640))])
       = (cond
           [else (clever-gcd_0 45014640 (remainder 101135853 45014640))])
       = (clever-gcd_0 45014640 (remainder 101135853 45014640))
       = (clever-gcd_0 45014640 11106573)
       = (cond
           [(= 11106573 0) 11106573]
           [else (clever-gcd_0 11106573 (remainder 45014640 11106573))])
       = (cond
           [false 11106573]
           [else (clever-gcd_0 11106573 (remainder 45014640 11106573))])
       = (cond
           [else (clever-gcd_0 11106573 (remainder 45014640 11106573))])
       = (clever-gcd_0 11106573 (remainder 45014640 11106573))
       = (clever-gcd_0 11106573 588348)
       = (cond
          [(= 11106573 0) 11106573]
          [else (clever-gcd_0 588348 (remainder 11106573 588348))])
       = (cond
          [false 11106573]
          [else (clever-gcd_0 588348 (remainder 11106573 588348))])
       = clever-gcd_0 588348 (remainder 11106573 588348))
       = (clever-gcd_0 588348 516309)
       = (cond
           [(= 516309 0) 588348]
           [else (clever-gcd_0 516309 (remainder 588348 516309))])
       = (cond
           [false 588348]
           [else (clever-gcd_0 516309 (remainder 588348 516309))])
       = (cond
           [else (clever-gcd_0 516309 (remainder 588348 516309))])
       = (clever-gcd_0 516309 (remainder 588348 516309))
       = (clever-gcd_0 516309 72039)
       = (cond
           [(= 72039 0) 516309]
           [else (clever-gcd 72039 (remainder 516309 72039))])
       = (cond
           [false 516309]
           [else (clever-gcd 72039 (remainder 516309 72039))])
       = (cond
           [else (clever-gcd 72039 (remainder 516309 72039))])       
       =  (clever-gcd 72039 (remainder 516309 72039))
       = (clever-gcd 72039 12036)
       = (cond
           [(= 12036 0) 72039]
           [else (clever-gcd 12036 (remainder 72039 12036))])
        = (cond
            [false 72039]
            [else (clever-gcd 12036 (remainder 72039 12036))])
        = (cond
            [else (clever-gcd 12036 (remainder 72039 12036))]) 
        = (clever-gcd 12036 (remainder 72039 12036))
        = (clever-gcd 12036 11859)
        = (cond
            [(= 0 11859) 12036]
            [else (clever-gcd 11859 (remainder 12036 11859))])
        = (cond
            [false 12036]
            [else (clever-gcd 11859 (remainder 12036 11859))])
        = (cond
            [else (clever-gcd 11859 (remainder 12036 11859))])
        = (clever-gcd 11859 (remainder 12036 11859))
        = (clever-gcd 11859 177)
        = (cond
            [(= 0 177) 11859]
            [else (clever-gcd 177 (remainder 11859 177))])
        = (cond
            [false 11859]
            [else (clever-gcd 177 (remainder 11859 177))])
       = (cond
           [else (clever-gcd 177 (remainder 11859 177))])
       = (clever-gcd 177 0)
       = (cond
           [(= 0 0) 177]
           [else (clever-gcd 177 (remainder 177 0))])
       = 177
       #+END_SRC

     - Exercise 26.3.4. Formulate a termination argument for
       gcd-generative. 

       The trivial solution is when the smaller number is 0. At every
       step, we take the former smaller number and make it the present
       larger, and the remainder of the present larger and smaller
       number and pass it as the smaller. Obviously the smaller number
       can only get smaller, that is, closer to 0. Both numbers will
       get smaller in each successive call, and eventually, one will
       reach 0, smaller will reach it first. 

   Considering the above example, it is tempting to develop functions
   using generative recursion. After all, they produce answers faster!
   This judgment is too rash for three reasons. First even a
   well-designed algorithm isn't always faster than an equivalent
   structurally recursive function. For example, quick-sort wins only
   for large lists; for small ones, the standard sort function is
   faster. Worse, a badly designed algorithm can wreak havoc on the
   performance of a program. Second, it is typically easier to design
   a function using the recipe for structural recursion. Conversely,
   designing an algorithm requires an idea of how to generate new,
   smaller problems, a step that often requires deep mathematical
   insight. Finally, people who read functions can easily understand
   structurally recursive functions, even without much
   documentation. To understand an algorithm, the generative step must
   be well explained, and even with a good explanation, it may still
   be difficult to grasp the idea. 

   Experience shows that most functions in a program employ structural
   recursion; only a few exploit generative recursion. When we
   encounter a situation where a design could use either the recipe
   for structural or generative recursion, the best approach is often
   to start with a structural version. If it turns out to be too slow,
   the alternative design using generative recursion should be
   explored. If it is chosen, it is important to document the problem
   generation with good examples and give a good termination argument.

   - Exercise 26.3.5. Evaluate

     (quick-sort (list 10 6 8 9 14 12 3 11 14 16 2))

     by hand. Show only those lines that introduce a new recursive
     call to quick-sort. How many recursive applications of quick-sort
     are required? How many recursive applications of append? Suggest
     a general rule for a list of length N.

     #+BEGIN_SRC scheme
     (quick-sort (list 10 6 8 9 14 12 3 11 14 16 2))
     = (append 
        (quick-sort (list 6 8 9 3 2))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (quick-sort (list 3 2))
         (list 6)
         (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (append
          (quick-sort (list 2))
          (list 3)
          (quick-sort empty))
         (list 6)
         (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (append
          (append
           (quick-sort empty)
           (list 2)
           (quick-sort empty))
y          (list 3)
          (quick-sort empty))
         (list 6)
        (quick-sort (list 8 9)))
       (list 10)
       (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (append
          (append
           empty
           (list 2)
           (quick-sort empty))
          (list 3)
          (quick-sort empty))
         (list 6)
        (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (append
          (append
           empty
           (list 2)
           empty)
          (list 3)
          (quick-sort empty))
         (list 6)
        (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))

     = (append
        (append
         (append
          (list 2)
          (list 3)
          (quick-sort empty))
         (list 6)
        (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))     
     = (append
        (append
         (append
          (list 2)
          (list 3)
          empty)
         (list 6)
        (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
        (quick-sort (list 8 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          (quick-sort empty)
          (list 8)
          (quick-sort (list 9))))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          empty
          (list 8)
          (quick-sort (list 9))))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          empty
          (list 8)
          (append
           (quick-sort empty)
           (list 9)
           (quick-sort empty))))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          empty
          (list 8)
          (append
           empty
           (list 9)
           (quick-sort empty))))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          empty
          (list 8)
          (append
           empty
           (list 9)
           empty)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (append
          empty
          (list 8)
          (list 9)))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (append
         (list 2 3)
         (list 6)
         (list 8 9))
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (quick-sort (list 14 12 11 14 16)))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (quick-sort (list 12 11))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (quick-sort (list 11))
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (quick-sort (list 11))
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (quick-sort (list 11))
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (append 
           (quick-sort empty)
           (list 11)
          (quick-sort empty))
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (append 
           empty
           (list 11)
          (quick-sort empty))
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (append 
           empty
           (list 11)
           empty)
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (list 11)
          (list 12)
          (quick-sort empty))
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (append
          (list 11)
          (list 12)
          empty)
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (quick-sort (list 14 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          (quick-sort empty)
          (list 14)
          (quick-sort (list 16)))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          empty
          (list 14)
          (quick-sort (list 16)))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          empty
          (list 14)
          (append
           (quick-sort empty)
           (list 16)
           (quick-sort empty)))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          empty
          (list 14)
          (append
           empty
           (list 16)
           (quick-sort empty)))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          empty
          (list 14)
          (append
           empty
           (list 16)
           empty))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (append
          empty
          (list 14)
          (list 16))))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (append
         (list 11 12)
         (list 14)
         (list 14 16)))
     = (append
        (list 2 3 6 8 9)
        (list 10)
        (list 11 12 14 14 16))
     = (list 2 3 6 8 9 10 11 12 14 14 16)
     #+END_SRC
     22 calls to quicksort, 2*N, 11 calls to append, N. 
     Evaluate
     
     (quick-sort (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
      
     by hand. How many recursive applications of quick-sort are
     required? How many recursive applications of append? does this
     contradict the first part of the exercise?

     #+BEGIN_SRC scheme
     (define (quick-sort alon)
       (local ((define (items->= n alon) 
                 (filter (lambda (a-n) (>= a-n n)) alon))
               (define (items-< n alon)
                 (filter (lambda (a-n) (< a-n n)) alon)))
         (cond
           [(empty? alon) alon]
           [else
            (append (quick-sort 
                     (items-< (first alon) (rest alon)))
                    (list (first alon))
                    (quick-sort 
                     (items->= (first alon) (rest alon))))])))
     (quick-sort (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
     =  (local ((define (items->= n alon) 
                  (filter (lambda (a-n) (>= a-n n)) alon))
                 (define (items-< n alon)
                   (filter (lambda (a-n) (< a-n n)) alon)))
         (cond
           [(empty? (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
                    (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)]
           [else
            (append (quick-sort 
                     (items-< 
                      (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
                            (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))))
                    (list (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
                    (quick-sort 
                     (items->= (first 
                                (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
                               (rest 
                                (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))))]))

     = (local ((define (items->=_0 n alon)
                 (filter (lambda (a-n) (>= a-n n)) alon))
               (define (items-<_0 n alon)
                 (filter (lambda (a-n) (< a-n n)) alon)))
        (cond
          [(empty? (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
           (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)]
          [else (append (quick-sort
                         (items-<_0 
                          (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
                          (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))))
                        (list (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
                        (quick-sort
                         (items->=_0 (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)) 
                                     (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))))]))
     = (define (items->=_0 n alon)
         (filter (lambda (a-n) (>= a-n n)) alon))
       (define (items-<_0 n alon)
         (filter (lambda (a-n) (< a-n n)) alon))

       (cond
        [(empty? (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
         (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)]
        [else 
         (append
          (quick-sort
           (items-<_0
            (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
            (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))))
           (list (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
           (quick-sort 
            (items->=_0
             (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
             (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))))])
      

     = (append 
        (quick-sort
         empty)
        (list (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
        (quick-sort
         (items->=_0
          (first (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))
	  (rest (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14)))))
 
     = (append
        empty
        (list 1)
        (quick-sort
         (list 2 3 4 5 6 7 8 9 10 11 12 13 14)))
     = (append
        empty
        (list 1)
        (append
         (quick-sort empty)
         (list 2)
         (quick-sort (list  3 4 5 6 7 8 9 10 11 12 13 14))))
     = (append
        empty
        (list 1)
        (append
         (quick-sort empty)
         (list 2)
         (append
          (quick-sort empty)
          (list 3)
          (quick-sort (list 4 5 6 7 8 9 10 11 12 13 14)))))
     
     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
           (quick-sort empty)
           (list 4)
           (quick-sort (list 5 6 7 8 9 10 11 12 13 14))))))

     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
	   empty
           (list 4)
           (append
            (quick-sort empty)
            (list 5)
            (quick-sort (list 6 7 8 9 10 11 12 13 14)))))))

     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
	   empty
           (list 4)
           (append
            (quick-sort empty)
            (list 5)
            (append
             (quick-sort empty)
             (list 6)
             (quick-sort (list 7 8 9 10 11 12 13 14))))))))
     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
	   empty
           (list 4)
           (append
            (quick-sort empty)
            (list 5)
            (append
             (quick-sort empty)
             (list 6)
             (append
              (quick-sort empty)
              (list 7)
              (quick-sort (list 8 9 10 11 12 13 14)))))))))
     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
	   empty
           (list 4)
           (append
            (quick-sort empty)
            (list 5)
            (append
             (quick-sort empty)
             (list 6)
             (append
              (quick-sort empty)
              (list 7)
              (append
               (quick-sort empty)
               (list 8)
               (quick-sort (list 9 10 11 12 13 14))))))))))
     = (append
        empty
        (list 1)
        (append
         empty
         (list 2)
         (append
          empty
          (list 3)
          (append
	   empty
           (list 4)
           (append
            (quick-sort empty)
            (list 5)
            (append
             (quick-sort empty)
             (list 6)
             (append
              (quick-sort empty)
              (list 7)
              (append
               (quick-sort empty)
               (list 8)
               (append
                (quick-sort empty)
                (list 9)
                (append
                 (quick-sort empty)
                 (list 10)
                 (append
                 (quick-sort empty) ....)
     #+END_SRC

     2*N applications of quicksort and N applications of append for
     each element of the list, always, no matter what. The variable is
     in how much work has to be done by the filter functions. If the
     list starts out as N, and each iteration gets smaller by 1, in a
     pre-sorted list we do two passes over the list, each call does an
     n-1 pass over the list, 2*N times.

   - Exercise 26.3.6. Add sort and quick-sort to the Definitions
     window. Test the functions and then explore how fast each works
     on various lists. The experiment should confirm the claim that
     the plain sort function wins (in many comparisons) over
     quick-sort for short lists and vice versa. Determine the
     cross-over point. Then build a sort-quick-sort function that
     behaves like quick-sort for large lists and switches over to the
     plain sort function for lists below the cross-over point.

     Hints: (1) Use the ideas of exercise 26.3.5. to create test
     cases. (2) Develop create-tests, a function that creates large
     test cases randomly. Then evaluate

     #+BEGIN_SRC
     (define test-case (create-tests 10000))
     (collect-garbage)
     (time (sort test-case))
     (collect-garbage)
     (time (quick-sort test-case))
     #+END_SRC
     
     The uses of collect-garbage helps DrScheme deal with large
     lists. 

     You can't tell - the time function displays 0 time for lists
     under the size of ~100 for both functions, by the time you can
     get a list large enough to measure, quick-sort is faster. 

     #+BEGIN_SRC scheme
     (define (sort-quick-sort alon)
       (local ((define THRESHOLD 10)
               (define (length<? n alon)
                 (cond ((and (empty? alon) (= 0 n)) false)
                       ((and (empty? alon) (> 0 n)) true)
                       ((and (cons? alon) (= 0 n)) false)
                       ((and (cons? alon) (> 0 n))
                        (length<? (sub1 n) (rest alon)))))
               (define (items-< alon)
                 (filter (lambda (a-n) (< a-n n)) alon))
               (define (items->= alon) 
                 (filter (lambda (a-n) (>= a-n n)) alon))
               (define (insert n alon)
                 (cond ((empty? alon) (list n))
                       (else (cond
                               ((< n (first alon)) (cons n alon))
                               (else (cons (first alon) 
                                           (insert n (rest alon))))))))
               (define (isort alon)
                 (cond ((empty? alon) alon)
                       (else (insert (first alon) (sort (rest alon))))))
               (define (quick-sort alon)
                 (cond
                   ((length<? THRESHOLD alon) (isort alon))
                   (else (append (quick-sort (items-< (first alon) alon))
                                 (list (first alon))
                                 (quick-sort (items->= (first alon) (rest alon))))))))
        (quick-sort alon)))
     #+END_SRC
