* Section 22
** Designing Abstractions with First-Class Functions
   We have seen that functions can consume functions and how important
   that is for creating single points of control in a function. But
   functions not only can consume functions, they can also produce
   them. More precisely, expressions in the new Scheme can evaluate to
   functions. Because the body of a function definition is also an
   expression, a function can produce a function. In this section, we
   first discuss this surprising idea and then show how it is useful
   for abstracting functions and in other contexts. 

*** 22.1 Functions that Produce Functions
    While the idea of producing a function may seem strange at first,
    it is extremely useful. Before we can discuss the usefulness of
    the idea, though, we must explore how a function can produce a
    function. Here are three examples:

    #+BEGIN_SRC scheme
    (define (f x) first)
    (define (g x) f)
    (define (h x)
      (cond
        ((empty? x) f)
	((cons? x) g)))
    #+END_SRC

    The body of f is first, a primitive operation, so applying f to
    any argument always evaluates to first. Similarly, the body of g
    is f, so applying g to any argument always evaluates to
    f. Finally, depending on what kind of list we supply as an
    argument to h, it produces f or g. 

    None of these examples is useful but each illustrates the basic
    idea. In the first two cases, the body of the function definition
    is a function. In the last case, it evaluates to a function. The
    examples are useless because the results do not contain or refer
    to the argument. For a function f to produce a function that
    contains one of f's arguments, f must define a function and return
    it as a result. That is, f's body must be a local-expression. 

    Recall that *local*-expressions group definitions and ask DrScheme
    to evaluate a single expression in the context of these
    definitions. They can occur wherever an expression can occur,
    which means the following definition is legal:

    #+BEGIN_SRC scheme
    (define (add x)
      (local ((define (x-adder y) (+ x y)))
        x-adder))
    #+END_SRC

    The function add consumes a number; after all, x is added to y. It
    then defines the function x-adder with a local-expression. The
    body of the local-expression is x-adder, which means the result of
    add is x-adder.

    To understand add better, let us look at how an application of add
    to some number evaluates

    #+BEGIN_SRC scheme
      (define f (add 5))
    = (define f (local ((define (x-adder y) (+ 5 y))) x-adder))
    = (define f (local ((define (x-adder_0 y) (+ 5 y))) x-adder_0))
    = (define (x-adder_0 y) (+ 5 y))
      (define f x-adder_0)
    #+END_SRC

    The last step adds the function x-adder_0 to the collection of our
    definitions; the evaluation continues with the body of the
    *local*-expression, x-adder_0, which is the name of a function,
    and thus a value. Now f is defined and we can use it:

    #+BEGIN_SRC scheme
      (f 10)
    = (x-adder_0 10)
    = (+ 5 10)
    = (15)
    #+END_SRC

    That is, f stands for x-adder_0, a function, which adds 5 to its
    argument. 

    Using this example, we can write add's contract and a purpose
    statement:

    #+BEGIN_SRC scheme
    ;; add : number -> (number -> number)
    ;; to create a function that adds x to its input
    (define (add x)
      (local ((define (x-adder y) (+ x y)))
        x-adder))
    #+END_SRC

    The most interesting property of add is that the result
    ``remembers'' the value of x. For example, every time we use f, it
    uses 5, the value of x, when add was used to define f. This form
    of ``memory'' is the key to our simple recipe for defining
    abstract functions, which we discuss in the next section.

*** 22.2. Designing Abstractions with Functions-as-Values
    The combination of *local*-expressions and functions-as-values
    simplifies our recipe for creating abstract functions. Consider
    our very first example in figure 53 again. If we replace the
    contents of the boxes with rel-op, we get a function that has a
    free variable. To avoid this, we can either add rel-op to the
    parameters or we can wrap the definition in a local and prefix it
    with a function that consumes rel-op. Figure 59 shows what happens
    when we use this idea with filter. If we also make the locally
    defined function the result of the function, we have defined an
    abstraction of the two original functions.

    #+BEGIN_SRC scheme
    (define (filter2 rel-op)
      (local ((define (abs-fun alon t)
                (cond
		  [(empty? alon) empty]
		  [else
		    (cons
		      [(rel-op (first alon) t)
		       (cons (first alon)
		             (abs-fun (rest alon) t))]
		      [else (abs-fun (rest alon) t)])])))
	abs-fun))
    #+END_SRC

    Put differently, we follow the example of add in the preceding
    section. Like add, filter2 consumes an argument, defines a
    function, and returns this function as a result. The result
    remembers the rel-op argument for good as the following evaluation
    shows:

    #+BEGIN_SRC scheme
    (filter2 <)

    = (local ((define (abs-fun alon t)
                (cond
		  [(empty? alon) empty]
		  [else 
		    (cond
		      [(< (first alon) t)
		       (cons (first alon)
		             (abs-fun (rest alon) t))]
		      [else (abs-fun (rest alon) t)])])))
        abs-fun)
    = (define (below3 alon t)
        (cond
	  [(empty? alon) empty]
	  [else
	    (cond
	      [(< (first alon) t)
	       (cons (first alon)
	             (below3 (rest alon) t))]
	      [else (below3 (rest alon) t)])]))
      below3
    #+END_SRC

    Remember that as we lift a local definition to the top-level
    definitions, we also rename the function in case the same local is
    evaluated again. Here we choose the name below3 to indicate what
    the function does. And indeed, a comparison between below and
    below3 reveals that the only difference is the name of the
    function.

    From the calculation, it follows that we can give the result of
    (filter2 <) a name and use it as if it were below. More
    succinctly, 

    #+BEGIN_SRC scheme
    (define below2 (filter2 <))
    #+END_SRC
    
    is equivalent to

    #+BEGIN_SRC scheme
    (define (below3 alon t)
      (cond
        [(empty? alon) empty]
	[else 
	  (cond
	    [(< (first alon) t)
	     (cons (first alon)
	           (below3 (rest alon) 3))]
            [else (below3 (rest alon) t)])]))
    (define below2 below3)
    #+END_SRC
    
    which means below2 is just another name for below3 and which
    directly proves that our abstract function correctly implements
    below. 

    The example suggests a variant of the abstraction recipe from
    section 21:

    - The Comparison:
      The new recipe still requires us to compare and mark the differences.
    - The abstraction:
      The new step concerns the way we define the abstract
      function. We place one of the functions into a
      *local*-expression and use the name of the function as the body
      of the local:

      #+BEGIN_SRC scheme
      (local ((define (concrete-fun x y z)
               ... op1 ... op2 ...))
        concrete-fun)
      #+END_SRC

      From that, we can create the abstract function by listing the
      names in the boxes as parameters:

      #+BEGIN_SRC scheme
      (define (abs-fun op1 op2)
        (local ((define (concrete-fun x y z)) ... op1 ... op2)
           concrete-fun))
      #+END_SRC

      If op1 or op2 is a special symbol, say <, we name it something
      that is more meaningful in the new context.
    - The test:
      To test the abstract function, we define the concrete functions
      again, as before. Consider the example of below and
      above. Obtaining below and above as instances of filter2 is now
      straightforward:

      #+BEGIN_SRC scheme
      (define below2 (filter2 <))
      (define above2 (filter2 >))
      #+END_SRC

      We simply apply filter2 to the contents of the box in the
      respective concrete function and that application produces the
      old function.
    - The contract:
      The contract of an abstract function contains two arrows. After
      all, the function produces a function, and to describe this
      relationship the type to the right of the first arrow must
      contain another arrow. 

      Here is the contract for filter2:

      #+BEGIN_SRC scheme
      ;; filter2 : (X Y -> boolean) -> ((listof X) Y -> (listof X))
      #+END_SRC

      It consumes a comparison function and produces a concrete
      filter-style function.

      The generalization of the contract works as before.

      Given our experience with the first design recipe, the second
      one is only a question of practice.

      - Exercise 22.2.1. Define an abstraction of the functions
        convertCF and names from section 21.1 Using the new recipe for
        abstraction.

	#+BEGIN_SRC scheme
	;; original functions

	;; convertCF : lon -> lon
	(define (convertCF alon)
	  (cond 
	    [(empty? alon) empty]
	    [else
	      (cons (C->F (first alon))
	            (convertCF (rest alon)))]))
	      
	;; names : loIR -> los
        (define (names aloIR)
	  (cond
	    [(empty? alon) empty]
	    [else 
	      (cons (IR-name (first alon))
	            (convertCF (rest alon)))]))

        ;; Differences, of things that are not just the function name:
	;; convertCF : lon -> lon
	(define (convertCF alon)
	  (cond 
	    [(empty? alon) empty]
	    [else
	      (cons (|C->F| (first alon))
	            (convertCF (rest alon)))]))
	      
	;; names : loIR -> los
        (define (names aloIR)
	  (cond
	    [(empty? alon) empty]
	    [else 
	      (cons (|IR-name| (first alon))
	            (names (rest alon)))]))

        ;; So, we abstract now in a different way. We place a new concrete function in a local, using boxed items as parameters.
	;; there was a single boxed difference so we have a single parameter to our function
	;; generating function.
	
	(define IR (name price))

	(define (C->F celsius)
	  (* 9/5 (+ 32 celsius)))

	(define (abs-map fun)
	  (local ((define (concrete-map alox)
                    (cond
		      ((empty? alox) empty)
		      (else (cons (fun (first alox))
                                  (concrete-map (rest alox)))))))
            abs-map))
        (define convertCF (absmap C->F))
	(define names (absmap IR-name))
        #+END_SRC

      - Exercise 22.2.2. Define an abstract version of sort (see
        exercise 19.1.6) using the new recipe for abstraction. 

	#+BEGIN_SRC scheme

        (define-struct ir (name price))
	;; sort : (listof number) -> (listof number)
	;; sort a list of numbers in descending order
	(define (isort alon)
	  (local ((define (sort alon)
	            (cond
	              ((empty? alon) empty)
                      (else (insert (first alon) (sort (rest alon))))))
                  (define (insert n alon)
                    (cond
                      ((empty? alon) (list n))
                      (else
                       (cond
                         ((> n (first alon)) (cons n alon))
                         (else (cons (first alon) 
                                     (insert n (rest alon)))))))))
           (sort alon)))
	
        (equal? (isort (list 4 2 1 1 20 3)) (list 20 4 3 2 1 1))
        (equal? (isort (list 50 1 2 22 23)) (list 50 23 22 2 1))
        (define (>ir ir1 ir2)
          (> (ir-price ir1) (ir-price ir2)))
	;; sort-ir : (listof IR) -> (listof IR)
	;; sort a list of inventory-records in 
	;; descending order of price.
	(define (sort-ir aloir)
	  (local ((define (sort-ir aloir)
	            (cond
                      ((empty? aloir) empty)
                      (else (insert (first aloir)
                                    (sort-ir (rest aloir))))))
                  (define (insert ir aloir)
                    (cond
                      ((empty? aloir) (list ir))
                      (else (cond
                              ((>ir ir (first aloir))
                               (cons ir aloir))
                              (else (cons (first aloir)
                                          (insert ir (rest aloir)))))))))
             (sort-ir aloir)))

        
        (equal? (sort-ir (list (make-ir 'dog 12) (make-ir 'cat 44)))
                (list (make-ir 'cat 44) (make-ir 'dog 12)))
        (equal? (sort-ir (list (make-ir 'rocket 44)
                               (make-ir 'car 66)
                               (make-ir 'doll 12)
                               (make-ir 'engine 555)))
                (list (make-ir 'engine 555)
                      (make-ir 'car 66)
                      (make-ir 'rocket 44)
                      (make-ir 'doll 12)))
        ;; Abstraction: compare the differences 
;
;	;; sort : (listof number) -> (listof number)
;	;; sort a list of numbers in descending order
;	(define (sort alon)
;	  (local ((define (sort alon)
;	            (cond
;	              ((empty? alon) empty)
;                      (else (insert (first alon) (sort (rest alon))))))
;                  (define (insert n alon)
;                    (cond
;                      ((empty? alon) (list n))
;                      (else
;                       (cond
;                         ((|>| n (first alon)) (cons n alon))
;                         (else (cons (first alon) 
;                                     (insert n (rest alon)))))))))
;           (sort alon)))
;	
;        (define (>ir ir1 ir2)
;          (> (ir-price ir1) (ir-price ir2)))
;	;; sort-ir : (listof IR) -> (listof IR)
;	;; sort a list of inventory-records in 
;	;; descending order of price.
;	(define (sort-ir aloir)
;	  (local ((define (sort-ir aloir)
;	            (cond
;                      ((empty? aloir) empty)
;                      (else (insert (first aloir)
;                                    (sort-ir (rest aloir))))))
;                  (define (insert ir aloir)
;                    (cond
;                      ((empty? aloir) (list ir))
;                      (else (cond
;                              ((|>ir| ir (first aloir))
;                               (cons ir aloir))
;                              (else (cons (first aloir)
;                                          (insert ir (rest aloir)))))))))
;             (sort-ir aloir)))
;
;        ;; the difference is only in the comparison function. So, we need a function that 
;        ;; consumes a comparison function and returns a sort function that sorts with that
;        ;; comparison  operator.
;
	;; abs-sort : (X X -> boolean) -> ((listof X) -> (listof X))
	;; produces a function that will sort a list of X according to the 
	;; comparison function compare.
	(define (abs-sort compare?)
	  (local ((define (sort alox)
	            (cond
	             ((empty? alox) empty)
	             (else (cons (insert (first alox)
	                                 (sort (rest alox)))))))
	          (define (insert x alox)
	            (cond
	              ((empty? alox) (list x))
	              (else (cond
	                      ((compare? x (first alox)) (cons x alox))
	                      (else (cons (first alox)
	                                  (insert x (rest alox)))))))))
	    sort))
	
        (define sort-ir2 (abs-sort >ir))
        (define sort2 (abs-sort >))

        (define sortlist1 (list 4 23 2 1))
        (define sortlist2 (list 6 2 19 28 2 10 100))

        (define sortirlist1 (list (make-ir 'robot 22) (make-ir 'cat 23) (make-ir 'rocket 102)))
        (define sortirlist2 (list (make-ir 'rocket 49) (make-ir 'car 209) (make-ir 'doll 22)))

        (equal? (sort2 sortlist1) (isort sortlist1))
        (equal? (sort2 sortlist2) (isort sortlist2))
        (equal? (sort-ir2 sortirlist1) (sort-ir sortirlist1))
        (equal? (sort-ir2 sortirlist2) (sort-ir sortirlist2))
	#+END_SRC

      - Exercise 22.2.3. Define fold using the new recipe for
        abstraction. Recall that fold abstracts the following pair of
        functions:
	
	#+BEGIN_SRC scheme
	;; sum : (listof number) -> number
	;; to compute the sum of alon
	(define (sum alon)
	  (cond
	    [(empty? alon) 0]
	    [else (+ (first alon) 
                     (sum (rest alon)))]))
 
        (equal? (+ 1 2 3 4) (sum (list 1 2 3 4)))
        (equal? (+ 2 4 6 8 10) (sum (list 2 4 6 8 10)))

	;; product : (listof number) -> number
	;; to compute the product of alon
	(define (product alon)
	  (cond
	    [(empty? alon) 1]
	    [else (* (first alon)
                     (product (rest alon)))]))

        (equal? (* 1 2 3) (product (list 1 2 3)))
        (equal? (* 1 2 3 4 5 6) (product (list 1 2 3 4 5 6)))
        ;; As always, we do a highlighting of differences:
;	;; sum : (listof number) -> number
;	;; to compute the sum of alon
;	(define (sum alon)
;	  (cond
;	    [(empty? alon) |0|]
;	    [else (|+| (first alon) 
;                     (sum (rest alon)))]))
;	;; product : (listof number) -> number
;	;; to compute the product of alon
;	(define (product alon)
;	  (cond
;	    [(empty? alon) |1|]
;	    [else (|*| (first alon)
;                     (product (rest alon)))]))
;

        ;; and, now that we see the differences we replace them with a parameter. 
        ;; this time the parameter(s) are given to a 'prefix' abstract function that
        ;; generates another function using a local definition. There are two parameters,
        ;; one is a 'base', and the other is an actual function, 'folder'. The base
        ;; is the result to return on an empty list and the folder takes an element from the list
        ;; and a result from the fold and applies the two, returning that as the result of the
        ;; fold function. These parameters are introduced into the lexical scope of a lcoally
        ;; defined fold function which 'remembers' them and uses them as values in it's definition.
        ;; we return this function as the concrete result of the abstract fold function.

        ;; fold : (X Y -> Y) -> ((listof X) Y -> Y)
        (define (fold folder base)
          (local ((define (fold alox)
                    (cond
                      ((empty? alox) base)
                      (else (folder (first alox)
                                    (fold base (rest alox)))))))
            fold))

        (define product1 (fold * 1))
        (define sum1 (fold + 0))

        (define prod1lst (list 10 7 7 28 1 2 30))
        (define prod2lst (list 10 7 8 9 1  200 3 2 1))
        (define sum1lst (list 1 2  10 2 3 4 300 1 20))
        (define sum2lst (list 1 5 0 1 203 27 28 320 32))
        (equal? (product1 prod1lst) (product prod1lst))
        (equal? (product1 prod2lst) (product prod2lst))
 
        (equal? (sum1 sum1lst) (sum sum1lst))
        (equal? (sum1 sum2lst) (sum sum2lst))
	#+END_SRC

	
	
*** 22.3 A First Look at Graphical User Interfaces
    Functions as first-class values play a central role in the design
    of graphical user interfaces. The term ``interface'' refers to the
    boundary between the program and a user. As long as we are the
    only users we can apply functions to data in DrScheme's
    Interactions window. If we want others to use our programs,
    though, we must provide a way to interact with the program that
    does not require any programming knowledge. The interaction
    between a program and a casual user is the USER INTERFACE. 

    A GRAPHICAL USER INTERFACE (GUI) is the most convenient interface
    for casual users. A GUI is a window that contains GUI items. Some
    of these items permit users to enter text; others are included so
    that users can apply a specific function; and yet others exist to
    display a function's results. Examples include _buttons_, in which
    the user can click with the mouse and which trigger a function
    application; _choice menus_, from which the user can choose one of
    a collection of values; _text fields_, into which the user can
    type arbitrary text; and _message fields_, into which a program
    can draw text. 

    Take a look at the simple GUI in figure 60. The left-most picture
    shows its initial state. In that state, the GUI contains a text
    field labeled ``Name'' and a message field labeled ``Number'' plus
    a ``LookUp'' button. In the second picture, the user has entered
    ``Sean'' but hasn't yet clicked the ``LookUp'' button. Finally,
    the right-most picture shows how the GUI displays the phone number
    of ``Sean'' after the user clicks the ``LookUp'' button.

    The core of the program is a function that looks up a phone number
    for a name in the a list. We wrote several versions of this
    function in part II but always used it with DrScheme's
    Interactions window. Using the GUI of figure 60, people who know
    nothing about Scheme can now use our function, too.

    To build a graphical user interface, we build structures that
    correspond to the GUI items and hand them over to a GUI
    manager. The latter constructs the visible window from these
    items. Some of the structures' fields describe the visual
    properties of the GUI's elements, such as the label of a button,
    the initial content of a message field, or available choices on a
    menu. Other fields stand for functions. They are called CALL-BACK
    FUNCTIONS because the GUI manager calls -- or applies -- these
    functions when the user manipulates the corresponding GUI
    element. Upon application, a call-back function obtains strings
    and (natural) numbers from the elements of the GUI and then
    applies the function proper. This last step computes answers,
    which the callback function can place into GUI elements just like
    graphics functions draw shapes on a canvas.

    The ideal program consists of two completely separate components:
    the MODEL, which is the kind of program we are learning to design,
    and a VIEW, which is the GUI program that manages the display of
    information and the user's mouse and keyboard manipulations. The
    bridge between teh two is the CONTROL expression. Figure 61
    graphically illustrates the organization, known as the
    MODEL-VIEW-CONTROL architecture. The lowest arrow indicates how a
    program makes up a button along with a call-back function. The
    left-to-right arrow depicts the mouse-click event and how it
    triggers an application of the call-back function. It, in turn,
    uses other GUI functions to obtain user input before it applies a
    core function or to display the results of the core function.

    The separation of the program into two parts means that the
    definitions for the model contain no references to the view, and
    that the definitions for the view contain no references to the
    data or the functionality of the model. The organization principle
    evolved over two decades from many good and bad experiences. It
    has the advantage that, with an adaptation of just the bridge
    expression, we can use one and the same program with different
    GUIs and vice versa. Furthermore, the construction of views
    requires different tools than does the construction of
    models. Constructing views is a labor-intensive effort that
    involves graphical design, but fortunately, it is often possible
    to generate large portions automatically. The construction of
    models, in contrast, will always demand a serious program design
    effort. 

    #+BEGIN_EXAMPLE
    A gui-item is either
    1. (make-button string (X -> true))
    2. (make-text string)
    3. (make-choices (listof string)) or
    4. (make-message string).

    ;; create-window :(listof (listof gui-item)) -> true
    ;; to add gui-items to the window and to show the window
    ;; each list of gui-items defines one row of gui items in the
    ;; window
    
    ;; hide-window : X -> true
    ;; to hide the window.

    ;; make-button : string (event% -> true) -> gui-item
    ;; to create a button with label and call-back function

    ;; make-message : string -> gui-item
    ;; to create an item that displays a message

    ;; draw-message : gui-item[message%] string -> true
    ;; to display a message in a message item
    ;; it erases teh current message.

    ;; make-text : string -> gui-item
    ;; to create an item (with label) that allows users to enter text.

    ;; text-contents : gui-item[text%] -> string
    ;; to determine the contents of a text field

    ;; make-choice : (listof string) -> gui-item
    ;; to create a choice menu that permits users to choose from some 
    ;; string alternatives.

    ;; choice-index : gui-item[choice%] -> num
    ;; to determien which choice is currently selected in a
    ;; choice-item result is the 0-based index in the choice menu
    #+END_EXAMPLE

    Here we study the simplified GUI world of the teachpack
    gui.ss. Figure 62 specifies the operations that the teachpack
    provides. The GUI manager is represented by the function
    create-window. Its contract and purpose statement are
    instructive. They explain that we create a window from a list. The
    function arranges these lists in a corresponding number of rows on
    the visible window. Each row is specified as a list of
    gui-items. The data definition for gui-items in figure 62 shows
    that there are four kinds:

    - Text fields,
      which are created with (make-text a-string) and allow users to
      enter arbitrary text into an area in the window;
    - buttons,
      which are created with (make-button a-string a-function) and
      allow users to apply a function with the click of a mouse
      button;
    - choice menus,
      which are created with (make-choice a-list-of-strings) and allow
      users to pick a choice from a specified set of choices; and
    - message fields, 
      which are created with (make-message a-string) and enable the
      model to inform users of results.

    The function that goes with a button is a function of one
    argument: an event. For most uses, we can ignore the event; it is
    simply a token that signals the user's click action. 

    How all this works is best illustrated with examples. Our first
    example is a canonical GUI program:

    (create-window (list (list (make-button "Close" hide-window))))

    It creates a window with a single button and equips it with the
    simplest of all call-backs: hide-window, the function that hides
    the window. When the user clicks the button labeled "Close", the
    window disappears.

    The second sample GUI copies what the user enters into the text
    field to a message field. We first create a text field and a
    message field:

    #+BEGIN_SRC scheme
    (define a-text-field (make-text "Enter Text:"))
    (define a-message (make-message "`Hello World' is a silly program"))
    #+END_SRC

    Now we can refer to these fields in a call-back function:

    #+BEGIN_SRC scheme
    ;; echo-message : X -> true
    ;; to extract the contents of a-text-field and to draw it into a-message
    (define (echo-message e)
    (draw-message a-message (text-contents a-text-field)))
    #+END_SRC

    The definition of the call-back function is based on our (domain)
    knowledge about gui-items. Specifically, the function echo-message
    obtains the current contents of the text field with text-contents
    as a string, and it draws its string into the message field with
    the draw-message function. To put everything together, we create a
    window with two rows:

    #+BEGIN_SRC scheme
    (create-window
     (list (list a-text-field a-message)
           (list (make-button "Copy Now" echo-message))))
    #+END_SRC

    The first row contains the text and the message field; the second
    one contains a button with the label "Copy Now" whose call-back
    function is echo-message. The user can now enter text into the
    text field, click the button, and see the text appear in the
    message field of the window.

    The purpose of the third and last example is to create a window
    with a choice menu, a message field, and a button. Clicking the
    button puts the current choice into the message field. As before,
    we start by defining the input and output gui-items:

    #+BEGIN_EXAMPLE scheme
    (define THE-CHOICES
      (list "green" "red" "yellow"))
    (define a-choice (make-choice THE-CHOICES))
    (define a-message
      (make-message (first THE-CHOICES)))
    #+END_SRC

    Because the list of choices is used more than once in the program,
    it is specified in a separate variable definition.

    As before, the call-back function for the button interacts with
    a-choice and a-message:

    #+BEGIN_SRC scheme
    ;; echo-choice : X -> true
    ;; to determine the current choice of a-choice and to draw 
    ;; the corresponding string into a-message
    (define (echo-choice e)
      (draw-message a-message
                    (list-ref THE-CHOICES
                              (choice-index a-choice))))
    #+END_SRC

    Specifically, the call-back function finds the 0-based index of a
    user's current choice with choice-index, uses Scheme's list-ref
    function to extract the corresponding string from THE-CHOICES, and
    then draws the result into the message field of the window. To
    create the window, we arrange a-choice and a-message into one row
    and the button in a row below:

    #+BEGIN_SRC scheme
    (create-window
     (list (list a-choice a-message)
           (list (make-button "Confirm Choice" echo-choice))))
    #+END_SRC

    #+BEGIN_SRC scheme
    ;; Model: 
    ;; build-number : (listof digit) -> number
    ;; to translate a list of digits into a number
    ;; example : (build-number (list 1 2 3)) = 123
    (define (build-number x) 
      (cond ((empty? (rest x)) (first x))
            (else (+ (* (first x) (expt 10 (length x)))
                     (build-number (rest x))))))

    
    ;; View: 
    ;; the ten digits as strings
    (define DIGITS
     (build-list 10 number->string))
     
    ;; a list of three digit choice menus
    (define digit-choosers
      (local ((define (builder i) (make-choice DIGITS)))
        (build-list 3 builder)))

    ;; a message field for saying hello and displaying the number
    (define a-msg
      (make-message "Welcome"))
    

    ;; Controller:
    ;; check-call-back : X -> true
    ;; to get the current choices of digits, convert them into a
    ;; number, and draw this number as a string into the message
    ;; field.
    (define (check-call-back b)
      (draw-message a-msg
                    (number->string 
                     (build-number (map choice-index
                                        digit-choosers)))))


    (create-window
     (list 
      (append digit-choosers (list a-msg))
      (list (make-button "Check Guess" check-call-back))))
    #+END_SRC

    - Exercise 22.3.1. Modify the program of figure 63 so that it
      implements the number-guessing game from exercises 5.1.2, 5.1.3,
      and 9.5.5. Make sure that the number of digits that the player
      must guess can be changed by editing a single definition in the
      program.

      #+BEGIN_SRC scheme
      ;; Model: 
      ;; build-number : (listof digit) -> number
      ;; to translate a list of digits into a number
      ;; example : (build-number (list 1 2 3)) = 123
      (define (build-number x) 
        (cond ((empty? (rest x)) (first x))
              (else (+ (* (first x) (expt 10 (length (rest x))))
                       (build-number (rest x))))))
      (define (maximum-value ndigits)
        (local ((define (nine n) 9))
          (build-number (build-list (sub1 ndigits) nine))))

      (equal? (maximum-value 1) 9)
      (equal? (maximum-value 2) 99)
      

      (define (check-guess guess real-value)
        (cond
         ((> guess real-value) 'TooLarge)
         ((< guess real-value) 'TooSmall)
         (else 'Perfect)))
      (equal? (check-guess 5 5) 'Perfect)
      (equal? (check-guess 4 5) 'TooSmall)
      (equal? (check-guess 7 5) 'TooLarge)

      (define NDIGITS 5)
      (define VALUE (random (maximum-value NDIGITS)))

      ;; View: 
      ;; the ten digits as strings
      (define DIGITS
       (build-list 10 number->string))
       
      ;; a list of three digit choice menus
      (define digit-choosers
        (local ((define (builder i) (make-choice DIGITS)))
          (build-list NDIGITS builder)))
      
      ;; a message field for saying hello and displaying the number
      (define a-msg
        (make-message "Welcome"))
      
      
      ;; Controller:
      ;; check-call-back : X -> true
      ;; to get the current choices of digits, convert them into a
      ;; number, and draw this number as a string into the message
      ;; field.
      (define (check-call-back b)
        (draw-message a-msg
                      (symbol->string
                       (check-guess 
                        (build-number (map choice-index
                                          digit-choosers))
                        VALUE))))
      
      (create-window
       (list 
        (append digit-choosers (list a-msg))
        (list (make-button "Check Guess" check-call-back))))      
      #+END_SRC scheme

    - Exercise 22.3.2. Develop a program for looking up phone
      numbers. The program's GUI should consist of a text field, a
      message field, and a button. The text field permits users to
      enter names. The message field should display the number that
      the model finds or the message "name not found", if the model
      produces false. 

      Generalize the program so that a user can also enter a phone
      number (as a sequence of digits containing no other characters).

      Hints: (1) Scheme provides the function string->symbol for
      converting a string to a symbol. (2) It also provides the
      function string->number, which converts a string to a number if
      possible. If the function consumes a string that doesn't
      represent a number, it produces false:

      #+BEGIN_SRC scheme
      (string->number "6670004")
      = 6670004
      (string->number "667-0004")
      = false

      The generalization demonstrates how one and the same GUI can use
      two distinct models. 

      Real-world GUIs: The graphical user interface in figure 60 was
      not constructed from the items provided by the teachpack. GUIs
      constructed with the teachpack's gui-items are primitive. They
      are sufficient, however, to study the basic principles of GUI
      programming. The design of real-world GUIs involves graphics
      designers and tools that generate GUI programs (rather than
      making them by hand). 
      
      -- 
      We can start by defining the model functions and testing them,
      then plugging them into the GUi which has basically been given
      to us in the examples. First, data definitions and function templates:
      #+BEGIN_SRC scheme
      #|
      ;; a PHONE-DIRECTORY is:
      ;; 1. empty or
      ;; 2. (cons pbr pd) where pd is a phone-directory and pbr is a
      ;; phone-book-record.
      ;; a phone-book-record is:
      ;; (make-pbr name number) where name is a symbol and number is a
      ;; number.
      |#
      (define-struct pbr (name number))

      #|
      ;; lookup-phone-number : symbol phone-directory -> number or false
      ;; finds the phone number of who in the phone-directory a-pd
      (define (lookup-phone-number who a-pd) ...)

      |# 
      ;; implementation: We see we are basically searching, something
      ;; that filter will do. 
      (define (lookup-phone-number who a-pd)
        (local ((define (is-person? a-pbr)
                  (equal? (pbr-name a-pbr) who))
		(define filter-result (filter is-person? a-pd)))
          (cond
           ((false? filter-result) false)
           (else (pbr-number (first (filter is-person? a-pd)))))))

      (define test-pd1 (list (make-pbr 'john 9996667777)
                             (make-pbr 'jack 6669998888)
                             (make-pbr 'max  8889996666)))
      (equal? (lookup-phone-number 'john test-pd1) 9996667777)
      (equal? (lookup-phone-number 'jack test-pd1) 6669998888)
      (equal? (lookup-phone-number 'max test-pd1)  8889996666)
      (equal? (lookup-phone-number 'noexist test-pd1) false)

      (define a-phone-directory
       (list (make-pbr 'john 9996668888)
             (make-pbr 'phillip 8889991111)
	     (make-pbr 'jack    6668887777)
	     (make-pbr 'jim  5558889999)))

      (define a-message (make-message "no one now"))
      (define a-text (make-text "Who are you looking for? "))

      (define (do-lookup e)
        (local ((define looked-up (lookup-phone-number 
                                   (string->symbol 
                                    (text-contents  a-text))
                                   a-phone-directory)))
          (cond
           ((false? looked-up) 
            (draw-message 
             a-message 
             "That person is not in the phonebook"))
	   (else (draw-message a-message (number->string looked-up))))))
                             

      (create-window
       (list (list a-message a-text)
             (list (create-button "Look up" do-lookup))))
      #+END_SRC scheme
    
    
       

	
